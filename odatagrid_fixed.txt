import React, { useRef, useEffect } from 'react';
import { Properties } from 'devextreme/ui/data_grid';
import DataGrid, {
  Column,
  Paging,
  Pager,
  FilterRow,
  Lookup,
  Sorting,
  Summary,
  TotalItem
} from 'devextreme-react/data-grid';
import ODataStore from 'devextreme/data/odata/store';
import DataSource, { Options } from 'devextreme/data/data_source';
import notify from 'devextreme/ui/notify';
import { useScreenSizeClass } from '../../utils/media-query';

export interface ODataGridColumn extends Partial<Column> {
  // Standard column properties
  dataField?: string; // Make optional to support command columns
  caption: string;
  width?: number;
  minWidth?: number;
  hidingPriority?: number;
  allowEditing?: boolean;
  dataType?: string;
  sortOrder?: 'asc' | 'desc';
  sortIndex?: number;
  fixed?: boolean;
  fixedPosition?: 'left' | 'right';
  name?: string; // Used to uniquely identify columns especially for button columns
  editorOptions?: {
    mask?: string;
    maskRules?: Record<string, RegExp>;
    useMaskedValue?: boolean;
    [key: string]: any;
  };
  customizeText?: (cellInfo: any) => string;
  cellRender?: (cellData: any) => React.ReactNode;
  calculateDisplayValue?: string;
  cellClass?: string;
  lookup?: {
    dataSource: any | { store: ODataStore };
    valueExpr: string;
    displayExpr: string | ((item: any) => string);
  };
  tooltip?: string;
  hint?: string;
  visible?: boolean;
  showSummary?: boolean;
  summaryType?: 'sum' | 'avg' | 'min' | 'max' | 'count';
  summaryFormat?: string | object;
  
  // Command column properties
  type?: 'buttons' | 'detailExpand' | 'selection';
  buttons?: Array<{
    name?: string;
    hint?: string;
    icon?: string;
    text?: string;
    visible?: boolean | ((e: any) => boolean);
    disabled?: boolean | ((e: any) => boolean);
    onClick?: (e: any) => void;
  }>;
  cellTemplate?: (container: any, options: any) => void;
}

interface ODataGridProps {
  title: string;
  endpoint?: string;
  dataSource?: any; // New prop to accept custom dataSource
  columns: ODataGridColumn[];
  keyField: string;
  defaultPageSize?: number;
  allowAdding?: boolean;
  allowUpdating?: boolean;
  allowDeleting?: boolean;
  onRowUpdating?: (e: any) => void;
  onRowInserting?: Properties['onRowInserting'];
  onRowRemoving?: Properties['onRowRemoving'];
  onInitNewRow?: Properties['onInitNewRow'];
  onRowValidating?: Properties['onRowValidating'];
  onEditorPreparing?: (e: any) => void;
  onInitialized?: (e: any) => void;
  onSaving?: (e: any) => void;
  defaultFilter?: [string, string, any][];
  defaultSort?: { selector: string; desc: boolean }[];
  expand?: string[];
  showRecordCount?: boolean;
  countColumn?: string;
  customGridHeight?: string | number;
  loading?: boolean; // Loading state prop
  storeOptions?: any; // Options passed to the ODataStore
  token: string; // Authentication token for API requests
  onTokenExpired?: () => Promise<string | null>; // Optional callback for token refresh when 401 occurs
}

export const ODataGrid: React.FC<ODataGridProps> = ({
  title,
  endpoint,
  dataSource: customDataSource, // Accept custom dataSource
  columns,
  keyField,
  defaultPageSize = 10,
  allowAdding = true,
  allowUpdating = true,
  allowDeleting = true,
  onRowUpdating,
  onRowInserting,
  onRowRemoving,
  onInitNewRow,
  onRowValidating,
  onEditorPreparing,
  onInitialized,
  onSaving: onSavingProp,
  defaultFilter = [],
  defaultSort,
  expand,
  showRecordCount = true,
  countColumn,
  customGridHeight,
  loading = false, // Default to false if not provided
  storeOptions = {},
  token, // Required token for API authentication API requests
  onTokenExpired // Optional callback for token refresh
}) => {
  const dataGridRef = useRef<DataGrid>(null);
  const screenSizeClass = useScreenSizeClass();
  
  // Reference to current token for use in store operations
  const currentTokenRef = useRef<string | null>(token);
  
  // Update token ref when prop changes
  useEffect(() => {
    currentTokenRef.current = token;
  }, [token]);

  let dataSourceInstance;

  // Use the provided custom dataSource if available, otherwise create one from the endpoint
  if (customDataSource) {
    dataSourceInstance = customDataSource;
  } else if (endpoint) {
    // Only create an ODataStore if an endpoint is provided
    // Merge default options with the provided storeOptions
    const store = new ODataStore({
      url: endpoint,
      version: 4,
      key: keyField,
      keyType: 'Guid',
      // Merge default fieldTypes with those provided in storeOptions.fieldTypes
      fieldTypes: {
        projectGuid: 'Guid',
        ...(storeOptions.fieldTypes || {})
      },
      beforeSend: (options: any) => {
        console.log('ODataGrid: beforeSend called for URL:', options.url);
        
        // Ensure headers object exists
        if (!options.headers) {
          options.headers = {};
        }
        
        // Use the current token from ref
        if (currentTokenRef.current) {
          options.headers['Authorization'] = `Bearer ${currentTokenRef.current}`;
          console.log('ODataGrid: Using token from ref');
        } 
        // Fall back to prop token if ref is not set
        else if (token) {
          options.headers['Authorization'] = `Bearer ${token}`;
          console.log('ODataGrid: Using token from props');
        }
        
        // Add method-specific headers for write operations
        const method = (options.method || '').toLowerCase();
        if (['patch', 'put', 'post'].includes(method)) {
          options.headers['Content-Type'] = 'application/json;odata.metadata=minimal';
          options.headers['Prefer'] = 'return=representation';
        }
        
        console.log('ODataGrid: Headers set, options:', JSON.stringify(options, (key, value) => 
          key === 'httpRequest' ? 'XHR_OBJECT' : value
        ));

        // Handle expand parameter based on the request method
        const url = new URL(options.url);
        
        if (method === 'get' && expand) {
          url.searchParams.set('$expand', expand.join(','));
        } else {
          url.searchParams.delete('$expand');
        }
        
        if ((method === 'patch' || method === 'put' || method === 'post') && expand && options.payload) {
          try {
            if (typeof options.payload === 'object' && options.payload !== null) {
              expand.forEach(navProp => {
                delete options.payload[navProp];
                delete options.payload[navProp.toLowerCase()];
              });
            } else if (typeof options.payload === 'string') {
              const payload = JSON.parse(options.payload);
              let modified = false;
              
              expand.forEach(navProp => {
                if (payload.hasOwnProperty(navProp) || payload.hasOwnProperty(navProp.toLowerCase())) {
                  delete payload[navProp];
                  delete payload[navProp.toLowerCase()];
                  modified = true;
                }
              });
              
              if (modified) {
                options.payload = JSON.stringify(payload);
              }
            }
          } catch (error) {
            console.error('Error modifying payload:', error);
          }
        }
        
        // Update the URL in the options
        options.url = url.toString();
        
        return true;
      },
      errorHandler: (error) => {
        // Extract error message from the error object
        // DevExtreme OData errors can have the message in different places
        let errorMessage = '';
        if (error.errorDetails && error.errorDetails.message) {
          errorMessage = error.errorDetails.message;
        } else if (error.errorDetails && typeof error.errorDetails === 'string') {
          errorMessage = error.errorDetails;
        } else if (error.requestOptions && error.requestOptions.data) {
          errorMessage = 'Operation failed';
        }
        
        // Handle validation errors (HTTP 400) using toast notifications
        if (error.httpStatus === 400) {
          notify({
            message: errorMessage || 'Cannot complete operation due to validation errors',
            type: 'error',
            displayTime: 3500,
            position: {
              at: 'top center',
              my: 'top center',
              offset: '0 10'
            },
            width: 'auto',
            animation: {
              show: { type: 'fade', duration: 300, from: 0, to: 1 },
              hide: { type: 'fade', duration: 300, from: 1, to: 0 }
            }
          });
          return true;
        }
        
        // Handle server errors (HTTP 500) using toast notifications
        if (error.httpStatus >= 500) {
          notify({
            message: errorMessage || 'A server error occurred. Please try again later.',
            type: 'error',
            displayTime: 3500,
            position: {
              at: 'top center',
              my: 'top center',
              offset: '0 10'
            }
          });
          return true;
        }
        
        // Let 401 errors pass through - they'll be handled by the onAjaxError handler
        return false;
      }
    });
  
    const dataSourceOptions: Options = {
      store,
      sort: defaultSort || [{ selector: 'created', desc: true }]
    };
  
    if (defaultFilter.length > 0) {
      dataSourceOptions.filter = defaultFilter;
    }
  
    dataSourceInstance = new DataSource(dataSourceOptions);
    
    // Add token refresh handler for 401 errors
    if (onTokenExpired) {
      dataSourceInstance.on('error', (e: any) => {
        const xhr = e?.xhr;
        if (xhr?.status === 401) {
          console.log('ODataGrid: 401 Unauthorized error detected');
          
          // Call the token refresh callback
          onTokenExpired().then((newToken) => {
            if (newToken) {
              console.log('ODataGrid: Token refreshed successfully');
              // Update current token reference
              currentTokenRef.current = newToken;
              
              // Reload the data source to retry the operation
              console.log('ODataGrid: Reloading data source with new token');
              dataSourceInstance.reload();
            } else {
              console.log('ODataGrid: Token refresh failed, redirecting to login');
              localStorage.removeItem('user');
              window.location.href = '/login';
            }
          }).catch(err => {
            console.error('ODataGrid: Error refreshing token:', err);
            localStorage.removeItem('user');
            window.location.href = '/login';
          });
          
          return true; // Prevent default error handling
        }
        
        return false; // Allow default error handling for other errors
      });
    }
  } else {
    // Throw error if neither endpoint nor dataSource is provided
    throw new Error('Either endpoint or dataSource must be provided to ODataGrid');
  }

  // Generate summary items for numeric fields
  const numericColumnSummaries = columns
    .filter(column => 
      column.showSummary && 
      (column.dataType === 'number' || 
       column.summaryType === 'count')
    )
    .map(column => ({
      column: column.dataField,
      summaryType: column.summaryType || 'sum',
      valueFormat: column.summaryFormat,
      displayFormat: column.summaryType === 'count' 
        ? '{0} records' 
        : (column.summaryType === 'sum' 
            ? 'Total: {0}' 
            : `${column.summaryType}: {0}`)
    }));

  const onCellPrepared = (e: any) => {
    if (e.rowType === 'data') {
      const column = columns.find(col => col.dataField === e.column.dataField);
      if (column && (column.tooltip || column.hint)) {
        e.cellElement.title = column.tooltip || column.hint;
      }
    }
    
    if (e.rowType === 'header') {
      const column = columns.find(col => col.dataField === e.column.dataField);
      if (column && (column.tooltip || column.hint)) {
        if (e.cellElement.querySelector('.dx-datagrid-text-content')) {
          e.cellElement.querySelector('.dx-datagrid-text-content').title = column.tooltip || column.hint;
        } else {
          e.cellElement.title = column.tooltip || column.hint;
        }
      }
    }
  };

  const onSaving = (e: any) => {
    if (!e.changes || !e.changes.length) return;

    onSavingProp?.(e);
  };
  
  // Handle validation errors by showing them as popups for all screen sizes
  const handleRowValidating = (e: any) => {
    // Call the original validation handler if provided
    if (onRowValidating) {
      onRowValidating(e);
    }
    
    // If validation failed, show error as popup regardless of screen size
    if (!e.isValid) {
      // Use setTimeout to ensure this runs after the original handler finishes
      setTimeout(() => {
        notify({
          message: e.errorText || 'Validation error',
          type: 'error',
          displayTime: 3000,
          position: {
            at: 'top center',
            my: 'top center',
            offset: '0 10'
          }
        });
      }, 0);
    }
  };

  return (
    <React.Fragment>
      <h2 className={'content-block'}>{title}</h2>
      <div 
        className="grid-container" 
        style={{ 
          width: '100%', 
          overflowX: 'auto', 
          height: screenSizeClass === 'screen-x-small' || screenSizeClass === 'screen-small' ? '600px' : 'calc(100vh - 170px)' 
        }}
      >
        <DataGrid
          ref={dataGridRef}
          className={'dx-card wide-card'}
          dataSource={dataSourceInstance}
          showBorders={true}
          columnAutoWidth={true}
          allowColumnResizing={true}
          columnResizingMode="widget"
          height={screenSizeClass === 'screen-x-small' || screenSizeClass === 'screen-small' ? 550 : customGridHeight || 'calc(100vh - 185px)'}
          scrolling={{ 
            mode: "virtual",  
            useNative: false,  
            showScrollbar: 'onHover', 
            scrollByThumb: true       
          }}
          remoteOperations={{
            filtering: true,
            paging: true,
            sorting: true,
            grouping: false,
            summary: false,
            groupPaging: false
          }}
          onCellPrepared={onCellPrepared}
          editing={{
            mode: screenSizeClass === 'screen-x-small' || screenSizeClass === 'screen-small' ? 'popup' : 'cell',
            allowAdding: allowAdding,
            allowUpdating: allowUpdating,
            allowDeleting: allowDeleting,
            useIcons: true,
            popup: {
              title: `Edit ${title}`,
              showTitle: true,
              width: 800,
              height: 600,
              position: { my: 'center', at: 'center' }
            },
            form: {
              items: columns
                .filter((column) => !column.type && column.dataField && column.visible !== false) // Filter out command columns and hidden fields
                .map((column) => ({
                  dataField: column.dataField,
                  editorOptions: column.editorOptions || {}
                })),
              labelLocation: 'top'
            }
          }}
          onRowUpdating={onRowUpdating}
          onRowInserting={onRowInserting}
          onRowRemoving={onRowRemoving}
          onInitNewRow={onInitNewRow}
          onRowValidating={handleRowValidating}
          onEditorPreparing={onEditorPreparing}
          onInitialized={onInitialized}
          onSaving={onSaving}
        >
          <Sorting mode="multiple" />
          {screenSizeClass === 'screen-x-small' || screenSizeClass === 'screen-small' ? (
            <>
              <Paging defaultPageSize={defaultPageSize} />
              <Pager showPageSizeSelector={true} showInfo={true} />
            </>
          ) : (
            <Paging enabled={false} />
          )}
          <FilterRow visible={true} />
          {columns.map((column) => {
            // Create a unique key for each column
            const columnKey = column.dataField || `${column.type}-${column.name || column.caption}`; // Use name if available for better uniqueness
            
            // Pass all properties from column to DevExtreme Column component
            // Common properties that all columns should have (except key)
            const commonProps = {
              caption: column.caption,
              width: column.width,
              // Allow fixed position columns to be more compact if they have a specified width
              minWidth: (column.fixed && column.width) ? undefined : (column.minWidth || 150),
              allowEditing: column.allowEditing,
              cssClass: column.cellClass,
              sortOrder: column.sortOrder,
              sortIndex: column.sortIndex,
              fixed: column.fixed,
              fixedPosition: column.fixedPosition
            };
            
            // Handle command columns (type="buttons")
            if (column.type === 'buttons') {
              return (
                <Column
                  key={columnKey}
                  {...commonProps}
                  dataField={column.dataField} // Explicitly pass dataField for button columns
                  type={column.type}
                  buttons={column.buttons ? column.buttons.map(button => ({
                    name: button.name,
                    hint: button.hint,   // Tooltip text
                    icon: button.icon,   // Button icon
                    text: button.text,   // Button text
                    visible: button.visible,
                    disabled: button.disabled,
                    onClick: button.onClick
                  })) : []}
                  cellTemplate={column.cellTemplate}
                />
              );
            }
            
            // Handle regular data columns
            return (
              <Column
                key={columnKey}
                {...commonProps}
                dataField={column.dataField}
                dataType={column.dataType}
                editorOptions={column.editorOptions}
                customizeText={column.customizeText}
                cellRender={column.cellRender}
                calculateDisplayValue={column.calculateDisplayValue}
              >
                {column.lookup && (
                  <Lookup
                    dataSource={column.lookup.dataSource}
                    valueExpr={column.lookup.valueExpr}
                    displayExpr={column.lookup.displayExpr}
                  />
                )}
              </Column>
            );
          })}
          <Summary>
            {showRecordCount && (
              <TotalItem
                summaryType="count"
                displayFormat="Total records: {0}"
                showInColumn={countColumn || "bookingCode"}
              />
            )}
            {numericColumnSummaries.map((summary, index) => (
              <TotalItem
                key={index}
                column={summary.column}
                summaryType={summary.summaryType}
                valueFormat={summary.valueFormat}
                displayFormat={summary.displayFormat}
              />
            ))}
          </Summary>
        </DataGrid>
      </div>
    </React.Fragment>
  );
};
