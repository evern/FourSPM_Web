# Task ID: 3
# Title: API Integration with MSAL Tokens
# Status: done
# Dependencies: 2
# Priority: high
# Description: Update the base API service to include access tokens from MSAL and implement automatic token acquisition and refresh.
# Details:
1. Create an API service with MSAL token integration (src/services/apiService.ts):
```typescript
import { msalInstance } from '../auth/msalInstance';
import { loginRequest } from '../auth/msalConfig';

interface ApiOptions {
  method?: string;
  headers?: Record<string, string>;
  body?: any;
}

class ApiService {
  private baseUrl: string;
  
  constructor(baseUrl: string) {
    this.baseUrl = baseUrl;
  }
  
  private async getAuthToken(): Promise<string> {
    try {
      const account = msalInstance.getAllAccounts()[0];
      if (!account) {
        throw new Error('No active account! Signin required.');
      }
      
      const response = await msalInstance.acquireTokenSilent({
        ...loginRequest,
        account
      });
      
      return response.accessToken;
    } catch (error) {
      // If silent token acquisition fails, try interactive method
      if (error instanceof Error && error.message.includes('interaction_required')) {
        try {
          const response = await msalInstance.acquireTokenPopup(loginRequest);
          return response.accessToken;
        } catch (interactiveError) {
          throw interactiveError;
        }
      }
      throw error;
    }
  }
  
  private async fetchWithAuth(url: string, options: ApiOptions = {}): Promise<Response> {
    try {
      const token = await this.getAuthToken();
      
      const headers = {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`,
        ...options.headers
      };
      
      const config: RequestInit = {
        method: options.method || 'GET',
        headers,
        body: options.body ? JSON.stringify(options.body) : undefined
      };
      
      const response = await fetch(`${this.baseUrl}${url}`, config);
      
      if (!response.ok) {
        // Handle different error status codes
        if (response.status === 401) {
          // Token might be expired, try to refresh
          msalInstance.acquireTokenRedirect(loginRequest);
        }
        
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.message || `API error: ${response.status}`);
      }
      
      return response;
    } catch (error) {
      console.error('API request failed:', error);
      throw error;
    }
  }
  
  async get<T>(url: string, options: ApiOptions = {}): Promise<T> {
    const response = await this.fetchWithAuth(url, { ...options, method: 'GET' });
    return response.json();
  }
  
  async post<T>(url: string, data: any, options: ApiOptions = {}): Promise<T> {
    const response = await this.fetchWithAuth(url, {
      ...options,
      method: 'POST',
      body: data
    });
    return response.json();
  }
  
  async put<T>(url: string, data: any, options: ApiOptions = {}): Promise<T> {
    const response = await this.fetchWithAuth(url, {
      ...options,
      method: 'PUT',
      body: data
    });
    return response.json();
  }
  
  async delete<T>(url: string, options: ApiOptions = {}): Promise<T> {
    const response = await this.fetchWithAuth(url, {
      ...options,
      method: 'DELETE'
    });
    return response.json();
  }
}

// Create and export a default instance
const apiService = new ApiService(process.env.REACT_APP_API_BASE_URL || '/api');
export default apiService;
```

2. Create a separate file to export the MSAL instance (src/auth/msalInstance.ts):
```typescript
import { PublicClientApplication } from '@azure/msal-browser';
import { msalConfig } from './msalConfig';

export const msalInstance = new PublicClientApplication(msalConfig);
```

3. Update environment files to include API base URL:
```
REACT_APP_API_BASE_URL=https://api.example.com
```

4. Create a hook for API calls with authentication (src/hooks/useApi.ts):
```typescript
import { useState, useCallback } from 'react';
import apiService from '../services/apiService';

interface ApiState<T> {
  data: T | null;
  loading: boolean;
  error: Error | null;
}

export function useApi<T>() {
  const [state, setState] = useState<ApiState<T>>({
    data: null,
    loading: false,
    error: null
  });
  
  const execute = useCallback(async (method: 'get' | 'post' | 'put' | 'delete', url: string, data?: any) => {
    setState(prev => ({ ...prev, loading: true, error: null }));
    
    try {
      const response = await apiService[method]<T>(url, data);
      setState({ data: response, loading: false, error: null });
      return response;
    } catch (error) {
      setState({ data: null, loading: false, error: error as Error });
      throw error;
    }
  }, []);
  
  return {
    ...state,
    get: useCallback((url: string) => execute('get', url), [execute]),
    post: useCallback((url: string, data: any) => execute('post', url, data), [execute]),
    put: useCallback((url: string, data: any) => execute('put', url, data), [execute]),
    delete: useCallback((url: string) => execute('delete', url), [execute])
  };
}
```

# Test Strategy:
1. Create unit tests for the ApiService class
2. Mock MSAL token acquisition and test successful token retrieval
3. Test token refresh logic when a token expires
4. Verify that API requests include the correct authorization headers
5. Test error handling for different HTTP status codes
6. Create integration tests that verify the complete flow from authentication to API request
7. Test the useApi hook with various API scenarios
