# Task ID: 11
# Title: Permission Changes Handling
# Status: deferred
# Dependencies: 2, 3, 9
# Priority: low
# Description: Implement logic to detect and handle permission changes during a user's session without requiring re-login.
# Details:
1. Create a permission change detector (src/auth/PermissionChangeDetector.tsx):
```typescript
import React, { useEffect, useState, useCallback } from 'react';
import { useMsal } from '@azure/msal-react';
import { loginRequest } from './msalConfig';
import { useAuth } from './AuthContext';
import { useToast } from '../components/ToastContainer';

interface PermissionChangeDetectorProps {
  children: React.ReactNode;
  checkInterval?: number; // in milliseconds
}

const PermissionChangeDetector: React.FC<PermissionChangeDetectorProps> = ({ 
  children, 
  checkInterval = 5 * 60 * 1000 // Default: check every 5 minutes
}) => {
  const { instance, accounts } = useMsal();
  const { user, setUser } = useAuth();
  const { showToast } = useToast();
  const [lastRoles, setLastRoles] = useState<string[]>([]);
  
  // Function to check for permission changes
  const checkPermissions = useCallback(async () => {
    if (!user || accounts.length === 0) return;
    
    try {
      // Get a fresh token to get the latest claims
      const response = await instance.acquireTokenSilent({
        ...loginRequest,
        account: accounts[0],
        forceRefresh: true // Force a fresh token from AAD
      });
      
      // Extract roles from token claims
      const idTokenClaims = response.idTokenClaims as any;
      const currentRoles = idTokenClaims.roles || [];
      
      // Compare with previous roles
      if (lastRoles.length > 0 && JSON.stringify(lastRoles) !== JSON.stringify(currentRoles)) {
        // Roles have changed
        const addedRoles = currentRoles.filter((role: string) => !lastRoles.includes(role));
        const removedRoles = lastRoles.filter(role => !currentRoles.includes(role));
        
        // Update user in context
        setUser({
          ...user,
          roles: currentRoles
        });
        
        // Notify user about changes
        if (addedRoles.length > 0 || removedRoles.length > 0) {
          let message = 'Your permissions have been updated.';
          
          if (addedRoles.length > 0) {
            message += ` Added: ${addedRoles.join(', ')}.`;
          }
          
          if (removedRoles.length > 0) {
            message += ` Removed: ${removedRoles.join(', ')}.`;
          }
          
          showToast(message, 'info');
        }
      }
      
      // Update last roles
      setLastRoles(currentRoles);
    } catch (error) {
      console.error('Error checking for permission changes:', error);
    }
  }, [instance, accounts, user, lastRoles, setUser, showToast]);
  
  // Initialize lastRoles when user is first loaded
  useEffect(() => {
    if (user && user.roles && lastRoles.length === 0) {
      setLastRoles(user.roles);
    }
  }, [user, lastRoles]);
  
  // Set up interval to check for permission changes
  useEffect(() => {
    if (!user) return;
    
    const intervalId = setInterval(checkPermissions, checkInterval);
    
    return () => clearInterval(intervalId);
  }, [user, checkPermissions, checkInterval]);
  
  return <>{children}</>;
};

export default PermissionChangeDetector;
```

2. Update the AuthContext to include setUser function (src/auth/AuthContext.tsx):
```typescript
interface AuthContextType {
  user: User | null;
  setUser: React.Dispatch<React.SetStateAction<User | null>>;
  isAuthenticated: boolean;
  isLoading: boolean;
  error: Error | null;
  login: () => Promise<void>;
  logout: () => Promise<void>;
}

export const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  // ... existing code
  const [user, setUser] = useState<User | null>(null);
  
  // ... rest of the component
  
  const contextValue: AuthContextType = {
    user,
    setUser,
    isAuthenticated: !!user,
    isLoading: inProgress !== InteractionStatus.None,
    error,
    login,
    logout
  };
  
  return (
    <AuthContext.Provider value={contextValue}>
      {children}
    </AuthContext.Provider>
  );
};
```

3. Add the PermissionChangeDetector to the App component (src/App.tsx):
```typescript
import PermissionChangeDetector from './auth/PermissionChangeDetector';

function App() {
  return (
    <AuthProvider>
      <PermissionChangeDetector>
        {/* Rest of your application */}
      </PermissionChangeDetector>
    </AuthProvider>
  );
}
```

4. Create a hook to check permissions (src/hooks/usePermission.ts):
```typescript
import { useAuth } from '../auth/AuthContext';

export function usePermission(requiredPermission: string | string[]) {
  const { user } = useAuth();
  
  if (!user || !user.roles) {
    return false;
  }
  
  const permissions = Array.isArray(requiredPermission) 
    ? requiredPermission 
    : [requiredPermission];
  
  return permissions.some(permission => user.roles.includes(permission));
}
```

5. Create a conditional rendering component based on permissions (src/components/PermissionGate.tsx):
```typescript
import React from 'react';
import { usePermission } from '../hooks/usePermission';

interface PermissionGateProps {
  permissions: string | string[];
  children: React.ReactNode;
  fallback?: React.ReactNode;
}

const PermissionGate: React.FC<PermissionGateProps> = ({ 
  permissions, 
  children, 
  fallback = null 
}) => {
  const hasPermission = usePermission(permissions);
  
  return hasPermission ? <>{children}</> : <>{fallback}</>;
};

export default PermissionGate;
```

6. Use the PermissionGate component for conditional rendering (example):
```typescript
import PermissionGate from '../components/PermissionGate';

const Dashboard: React.FC = () => {
  return (
    <div>
      <h1>Dashboard</h1>
      
      {/* This section only shows for users with the 'Admin' role */}
      <PermissionGate permissions="Administrator">
        <div className="admin-section">
          <h2>Administration</h2>
          <p>This content is only visible to administrators.</p>
        </div>
      </PermissionGate>
      
      {/* This section shows for users with either 'Editor' or 'Contributor' roles */}
      <PermissionGate permissions={['Editor', 'Contributor']}>
        <div className="content-section">
          <h2>Content Management</h2>
          <p>This content is only visible to editors and contributors.</p>
        </div>
      </PermissionGate>
    </div>
  );
};
```

# Test Strategy:
1. Create unit tests for the PermissionChangeDetector component
2. Test the detection of added and removed roles
3. Verify that the user context is updated when roles change
4. Test that appropriate notifications are shown when permissions change
5. Verify that the usePermission hook correctly checks for permissions
6. Test the PermissionGate component with various permission scenarios
7. Verify that UI elements are correctly shown/hidden based on permission changes
8. Test the complete flow of permission changes during a user session
