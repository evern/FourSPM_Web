{
  "tasks": [
    {
      "id": 1,
      "title": "MSAL Library Integration",
      "description": "Integrate Microsoft Authentication Library (MSAL) packages into the React application and configure the basic MSAL parameters.",
      "details": "1. Install required MSAL packages:\n```bash\nnpm install @azure/msal-browser @azure/msal-react --save\n```\n2. Create a configuration file (src/auth/msalConfig.ts) with the following structure:\n```typescript\nimport { Configuration, LogLevel } from '@azure/msal-browser';\n\nexport const msalConfig: Configuration = {\n  auth: {\n    clientId: process.env.REACT_APP_AZURE_CLIENT_ID || 'c67bf91d-8b6a-494a-8e99-c7a4592e08c1',\n    authority: `https://login.microsoftonline.com/${process.env.REACT_APP_AZURE_TENANT_ID || '3c7fa9e9-64e7-443c-905a-d9134ca00da9'}`,\n    redirectUri: window.location.origin,\n    postLogoutRedirectUri: window.location.origin\n  },\n  cache: {\n    cacheLocation: 'sessionStorage',\n    storeAuthStateInCookie: false\n  },\n  system: {\n    loggerOptions: {\n      loggerCallback: (level, message, containsPii) => {\n        if (containsPii) return;\n        switch (level) {\n          case LogLevel.Error:\n            console.error(message);\n            break;\n          case LogLevel.Info:\n            console.info(message);\n            break;\n          case LogLevel.Verbose:\n            console.debug(message);\n            break;\n          case LogLevel.Warning:\n            console.warn(message);\n            break;\n        }\n      },\n      logLevel: process.env.NODE_ENV === 'development' ? LogLevel.Verbose : LogLevel.Warning\n    }\n  }\n};\n\nexport const loginRequest = {\n  scopes: ['User.Read']\n};\n```\n3. Update environment files (.env.development and .env.production) with the required configuration parameters:\n```\nREACT_APP_ENVIRONMENT=development|production\nREACT_APP_AZURE_CLIENT_ID=c67bf91d-8b6a-494a-8b99-c7a4592e08c1\nREACT_APP_AZURE_TENANT_ID=3c7fa9e9-64e7-443c-905a-d9134ca00da9\n```\n4. Create a MSAL instance provider in src/index.tsx:\n```typescript\nimport { PublicClientApplication } from '@azure/msal-browser';\nimport { MsalProvider } from '@azure/msal-react';\nimport { msalConfig } from './auth/msalConfig';\n\nconst msalInstance = new PublicClientApplication(msalConfig);\n\nReactDOM.render(\n  <React.StrictMode>\n    <MsalProvider instance={msalInstance}>\n      <App />\n    </MsalProvider>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n```",
      "testStrategy": "1. Verify that MSAL packages are correctly installed and imported\n2. Validate that the MSAL configuration is correctly set up with the provided Azure AD parameters\n3. Test that the MSAL instance is properly initialized\n4. Confirm that environment variables are correctly loaded\n5. Use browser developer tools to verify that the MSAL library is initialized without errors",
      "priority": "high",
      "dependencies": [],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 2,
      "title": "Authentication Context Refactoring",
      "description": "Replace the current AuthProvider with MSAL-based implementation and update the User type to include roles from Azure AD claims.",
      "details": "1. Create a new authentication context (src/auth/AuthContext.tsx):\n```typescript\nimport React, { createContext, useContext, useEffect, useState } from 'react';\nimport { useMsal, useAccount } from '@azure/msal-react';\nimport { InteractionStatus } from '@azure/msal-browser';\nimport { loginRequest } from './msalConfig';\n\ninterface User {\n  id: string;\n  displayName: string;\n  email: string;\n  roles: string[];\n}\n\ninterface AuthContextType {\n  user: User | null;\n  isAuthenticated: boolean;\n  isLoading: boolean;\n  error: Error | null;\n  login: () => Promise<void>;\n  logout: () => Promise<void>;\n}\n\nconst AuthContext = createContext<AuthContextType | undefined>(undefined);\n\nexport const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {\n  const { instance, accounts, inProgress } = useMsal();\n  const account = useAccount(accounts[0] || {});\n  const [user, setUser] = useState<User | null>(null);\n  const [error, setError] = useState<Error | null>(null);\n  \n  useEffect(() => {\n    const getUser = async () => {\n      if (account && inProgress === InteractionStatus.None) {\n        try {\n          const response = await instance.acquireTokenSilent({\n            ...loginRequest,\n            account: account\n          });\n          \n          // Extract user information from ID token claims\n          const idTokenClaims = response.idTokenClaims as any;\n          const roles = idTokenClaims.roles || [];\n          \n          setUser({\n            id: account.homeAccountId,\n            displayName: account.name || '',\n            email: account.username,\n            roles: roles\n          });\n        } catch (err) {\n          setError(err as Error);\n        }\n      } else {\n        setUser(null);\n      }\n    };\n    \n    getUser();\n  }, [account, inProgress, instance]);\n  \n  const login = async () => {\n    try {\n      await instance.loginPopup(loginRequest);\n    } catch (err) {\n      setError(err as Error);\n    }\n  };\n  \n  const logout = async () => {\n    try {\n      await instance.logoutPopup();\n    } catch (err) {\n      setError(err as Error);\n    }\n  };\n  \n  const contextValue: AuthContextType = {\n    user,\n    isAuthenticated: !!user,\n    isLoading: inProgress !== InteractionStatus.None,\n    error,\n    login,\n    logout\n  };\n  \n  return (\n    <AuthContext.Provider value={contextValue}>\n      {children}\n    </AuthContext.Provider>\n  );\n};\n\nexport const useAuth = (): AuthContextType => {\n  const context = useContext(AuthContext);\n  if (context === undefined) {\n    throw new Error('useAuth must be used within an AuthProvider');\n  }\n  return context;\n};\n```\n\n2. Update the App component to use the new AuthProvider:\n```typescript\nimport { AuthProvider } from './auth/AuthContext';\n\nfunction App() {\n  return (\n    <AuthProvider>\n      {/* Rest of your application */}\n    </AuthProvider>\n  );\n}\n```\n\n3. Create a utility function to check user roles (src/auth/roleUtils.ts):\n```typescript\nexport const hasRole = (user: { roles: string[] } | null, requiredRoles: string[]): boolean => {\n  if (!user || !user.roles) return false;\n  return requiredRoles.some(role => user.roles.includes(role));\n};\n```",
      "testStrategy": "1. Create unit tests for the AuthContext using React Testing Library\n2. Test the login and logout functions\n3. Verify that user information is correctly extracted from ID token claims\n4. Test role extraction and the hasRole utility function\n5. Verify that the context correctly updates when authentication state changes\n6. Test error handling for authentication failures",
      "priority": "high",
      "dependencies": [
        1
      ],
      "status": "done",
      "subtasks": [
        {
          "id": 1,
          "title": "Define the User type and interfaces",
          "description": "Create TypeScript interfaces for the User model that includes role-based access properties and MSAL account information",
          "dependencies": [],
          "details": "Define a comprehensive User interface that includes properties like id, name, email, roles array, permissions, and any MSAL-specific account information. Create additional interfaces for authentication state and context props that will be used throughout the application.",
          "status": "done"
        },
        {
          "id": 2,
          "title": "Implement AuthContext with MSAL React integration",
          "description": "Create a new AuthContext using MSAL React hooks and configure the MSAL instance",
          "dependencies": [
            1
          ],
          "details": "Set up the MSAL configuration in authConfig.js with proper Azure AD B2C settings. Create an AuthContext that uses MsalProvider and implements the PublicClientApplication from MSAL. Include methods for login, logout, and token acquisition. Wrap the context provider around the application in index.js.",
          "status": "done"
        },
        {
          "id": 3,
          "title": "Implement authentication state management",
          "description": "Handle authentication state changes and user information retrieval from MSAL",
          "dependencies": [
            2
          ],
          "details": "Create hooks or methods to track authentication state (logged in, logging in, error states). Implement functions to retrieve and process user information from MSAL accounts. Handle token refresh logic and session persistence. Implement proper error handling for authentication failures.",
          "status": "done"
        },
        {
          "id": 4,
          "title": "Implement role-based access control",
          "description": "Add role verification and permission checking functionality to the AuthContext",
          "dependencies": [
            1,
            3
          ],
          "details": "Create helper functions like hasRole(), hasPermission(), and isAuthorized() that check user roles against required permissions. Implement a higher-order component or hook for protecting routes based on roles. Add logic to extract role information from authentication tokens or user profile data.",
          "status": "done"
        },
        {
          "id": 5,
          "title": "Update App component and migrate from old provider",
          "description": "Refactor the App component to use the new MSAL-based AuthContext and ensure backward compatibility",
          "dependencies": [
            2,
            3,
            4
          ],
          "details": "Wrap the main application with MsalProvider and the custom AuthContext. Update any components that were using the old authentication provider to use the new context. Implement a migration strategy to handle the transition period. Update protected routes to use the new role-based access control.",
          "status": "done"
        },
        {
          "id": 6,
          "title": "Implement logout functionality",
          "description": "Create a logout method that correctly ends both the application session and the Azure AD session",
          "details": "Implement the logout function in the AuthContext that:\n\n1. Calls the MSAL instance's logout method to terminate the Azure AD session\n2. Clears the local user state in the AuthContext\n3. Redirects the user to the login page\n4. Ensures all application state related to the user is properly reset\n5. Handles any edge cases like offline logout\n\nThe logout function should be exposed through the AuthContext and should be callable from the user menu in the header component. The implementation should follow user story ST-103 which specifies that the logout option should be available in the user menu, clicking logout should end the session with both the application and Microsoft, the user should be redirected to the login page after logout, and the user should no longer be able to access protected routes without re-authentication.",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 2
        }
      ]
    },
    {
      "id": 3,
      "title": "API Integration with MSAL Tokens",
      "description": "Update the base API service to include access tokens from MSAL and implement automatic token acquisition and refresh.",
      "details": "1. Create an API service with MSAL token integration (src/services/apiService.ts):\n```typescript\nimport { msalInstance } from '../auth/msalInstance';\nimport { loginRequest } from '../auth/msalConfig';\n\ninterface ApiOptions {\n  method?: string;\n  headers?: Record<string, string>;\n  body?: any;\n}\n\nclass ApiService {\n  private baseUrl: string;\n  \n  constructor(baseUrl: string) {\n    this.baseUrl = baseUrl;\n  }\n  \n  private async getAuthToken(): Promise<string> {\n    try {\n      const account = msalInstance.getAllAccounts()[0];\n      if (!account) {\n        throw new Error('No active account! Signin required.');\n      }\n      \n      const response = await msalInstance.acquireTokenSilent({\n        ...loginRequest,\n        account\n      });\n      \n      return response.accessToken;\n    } catch (error) {\n      // If silent token acquisition fails, try interactive method\n      if (error instanceof Error && error.message.includes('interaction_required')) {\n        try {\n          const response = await msalInstance.acquireTokenPopup(loginRequest);\n          return response.accessToken;\n        } catch (interactiveError) {\n          throw interactiveError;\n        }\n      }\n      throw error;\n    }\n  }\n  \n  private async fetchWithAuth(url: string, options: ApiOptions = {}): Promise<Response> {\n    try {\n      const token = await this.getAuthToken();\n      \n      const headers = {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${token}`,\n        ...options.headers\n      };\n      \n      const config: RequestInit = {\n        method: options.method || 'GET',\n        headers,\n        body: options.body ? JSON.stringify(options.body) : undefined\n      };\n      \n      const response = await fetch(`${this.baseUrl}${url}`, config);\n      \n      if (!response.ok) {\n        // Handle different error status codes\n        if (response.status === 401) {\n          // Token might be expired, try to refresh\n          msalInstance.acquireTokenRedirect(loginRequest);\n        }\n        \n        const errorData = await response.json().catch(() => ({}));\n        throw new Error(errorData.message || `API error: ${response.status}`);\n      }\n      \n      return response;\n    } catch (error) {\n      console.error('API request failed:', error);\n      throw error;\n    }\n  }\n  \n  async get<T>(url: string, options: ApiOptions = {}): Promise<T> {\n    const response = await this.fetchWithAuth(url, { ...options, method: 'GET' });\n    return response.json();\n  }\n  \n  async post<T>(url: string, data: any, options: ApiOptions = {}): Promise<T> {\n    const response = await this.fetchWithAuth(url, {\n      ...options,\n      method: 'POST',\n      body: data\n    });\n    return response.json();\n  }\n  \n  async put<T>(url: string, data: any, options: ApiOptions = {}): Promise<T> {\n    const response = await this.fetchWithAuth(url, {\n      ...options,\n      method: 'PUT',\n      body: data\n    });\n    return response.json();\n  }\n  \n  async delete<T>(url: string, options: ApiOptions = {}): Promise<T> {\n    const response = await this.fetchWithAuth(url, {\n      ...options,\n      method: 'DELETE'\n    });\n    return response.json();\n  }\n}\n\n// Create and export a default instance\nconst apiService = new ApiService(process.env.REACT_APP_API_BASE_URL || '/api');\nexport default apiService;\n```\n\n2. Create a separate file to export the MSAL instance (src/auth/msalInstance.ts):\n```typescript\nimport { PublicClientApplication } from '@azure/msal-browser';\nimport { msalConfig } from './msalConfig';\n\nexport const msalInstance = new PublicClientApplication(msalConfig);\n```\n\n3. Update environment files to include API base URL:\n```\nREACT_APP_API_BASE_URL=https://api.example.com\n```\n\n4. Create a hook for API calls with authentication (src/hooks/useApi.ts):\n```typescript\nimport { useState, useCallback } from 'react';\nimport apiService from '../services/apiService';\n\ninterface ApiState<T> {\n  data: T | null;\n  loading: boolean;\n  error: Error | null;\n}\n\nexport function useApi<T>() {\n  const [state, setState] = useState<ApiState<T>>({\n    data: null,\n    loading: false,\n    error: null\n  });\n  \n  const execute = useCallback(async (method: 'get' | 'post' | 'put' | 'delete', url: string, data?: any) => {\n    setState(prev => ({ ...prev, loading: true, error: null }));\n    \n    try {\n      const response = await apiService[method]<T>(url, data);\n      setState({ data: response, loading: false, error: null });\n      return response;\n    } catch (error) {\n      setState({ data: null, loading: false, error: error as Error });\n      throw error;\n    }\n  }, []);\n  \n  return {\n    ...state,\n    get: useCallback((url: string) => execute('get', url), [execute]),\n    post: useCallback((url: string, data: any) => execute('post', url, data), [execute]),\n    put: useCallback((url: string, data: any) => execute('put', url, data), [execute]),\n    delete: useCallback((url: string) => execute('delete', url), [execute])\n  };\n}\n```",
      "testStrategy": "1. Create unit tests for the ApiService class\n2. Mock MSAL token acquisition and test successful token retrieval\n3. Test token refresh logic when a token expires\n4. Verify that API requests include the correct authorization headers\n5. Test error handling for different HTTP status codes\n6. Create integration tests that verify the complete flow from authentication to API request\n7. Test the useApi hook with various API scenarios",
      "priority": "high",
      "dependencies": [
        2
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 4,
      "title": "Route Protection Implementation",
      "description": "Create a RequireAuth component to protect routes based on authentication status and implement permission-based access control.",
      "details": "1. Create a RequireAuth component (src/auth/RequireAuth.tsx):\n```typescript\nimport React from 'react';\nimport { Navigate, useLocation } from 'react-router-dom';\nimport { useAuth } from './AuthContext';\n\ninterface RequireAuthProps {\n  children: React.ReactNode;\n  requiredRoles?: string[];\n}\n\nexport const RequireAuth: React.FC<RequireAuthProps> = ({ children, requiredRoles = [] }) => {\n  const { user, isAuthenticated, isLoading } = useAuth();\n  const location = useLocation();\n  \n  // Show loading indicator while authentication is in progress\n  if (isLoading) {\n    return <div className=\"loading-spinner\">Loading...</div>;\n  }\n  \n  // Redirect to login if not authenticated\n  if (!isAuthenticated) {\n    return <Navigate to=\"/login\" state={{ from: location }} replace />;\n  }\n  \n  // Check for required roles if specified\n  if (requiredRoles.length > 0) {\n    const hasRequiredRole = requiredRoles.some(role => \n      user?.roles.includes(role)\n    );\n    \n    if (!hasRequiredRole) {\n      return <Navigate to=\"/unauthorized\" replace />;\n    }\n  }\n  \n  return <>{children}</>;\n};\n```\n\n2. Create an Unauthorized page (src/pages/Unauthorized.tsx):\n```typescript\nimport React from 'react';\nimport { Link } from 'react-router-dom';\n\nconst Unauthorized: React.FC = () => {\n  return (\n    <div className=\"unauthorized-container\">\n      <h1>Unauthorized Access</h1>\n      <p>You do not have permission to access this resource.</p>\n      <Link to=\"/\" className=\"btn btn-primary\">Return to Dashboard</Link>\n    </div>\n  );\n};\n\nexport default Unauthorized;\n```\n\n3. Update the routing configuration to use RequireAuth (src/App.tsx):\n```typescript\nimport { BrowserRouter, Routes, Route, Navigate } from 'react-router-dom';\nimport { RequireAuth } from './auth/RequireAuth';\nimport Dashboard from './pages/Dashboard';\nimport Login from './pages/Login';\nimport Unauthorized from './pages/Unauthorized';\nimport RoleManagement from './pages/RoleManagement';\nimport PermissionManagement from './pages/PermissionManagement';\n\nfunction App() {\n  return (\n    <BrowserRouter>\n      <Routes>\n        <Route path=\"/login\" element={<Login />} />\n        <Route path=\"/unauthorized\" element={<Unauthorized />} />\n        \n        <Route path=\"/\" element={\n          <RequireAuth>\n            <Dashboard />\n          </RequireAuth>\n        } />\n        \n        <Route path=\"/roles\" element={\n          <RequireAuth requiredRoles={['Administrator']}>\n            <RoleManagement />\n          </RequireAuth>\n        } />\n        \n        <Route path=\"/roles/:roleId/permissions\" element={\n          <RequireAuth requiredRoles={['Administrator']}>\n            <PermissionManagement />\n          </RequireAuth>\n        } />\n        \n        <Route path=\"*\" element={<Navigate to=\"/\" replace />} />\n      </Routes>\n    </BrowserRouter>\n  );\n}\n\nexport default App;\n```\n\n4. Create a utility to conditionally render navigation items based on roles (src/components/Navigation.tsx):\n```typescript\nimport React from 'react';\nimport { Link } from 'react-router-dom';\nimport { useAuth } from '../auth/AuthContext';\n\ninterface NavItemProps {\n  to: string;\n  label: string;\n  requiredRoles?: string[];\n}\n\nconst NavItem: React.FC<NavItemProps> = ({ to, label, requiredRoles = [] }) => {\n  const { user } = useAuth();\n  \n  // Don't render if user doesn't have required roles\n  if (requiredRoles.length > 0 && \n      !requiredRoles.some(role => user?.roles.includes(role))) {\n    return null;\n  }\n  \n  return <li><Link to={to}>{label}</Link></li>;\n};\n\nconst Navigation: React.FC = () => {\n  const { isAuthenticated, logout } = useAuth();\n  \n  if (!isAuthenticated) return null;\n  \n  return (\n    <nav className=\"main-navigation\">\n      <ul>\n        <NavItem to=\"/\" label=\"Dashboard\" />\n        <NavItem to=\"/roles\" label=\"Role Management\" requiredRoles={['Administrator']} />\n        {/* Add other navigation items */}\n        <li><button onClick={logout}>Logout</button></li>\n      </ul>\n    </nav>\n  );\n};\n\nexport default Navigation;\n```",
      "testStrategy": "1. Create unit tests for the RequireAuth component using React Testing Library\n2. Test redirection to login page when user is not authenticated\n3. Test redirection to unauthorized page when user doesn't have required roles\n4. Verify that children are rendered when authentication and authorization checks pass\n5. Test the Navigation component to ensure it correctly shows/hides items based on user roles\n6. Test the complete routing flow with different authentication states\n7. Verify that protected routes cannot be accessed directly without authentication",
      "priority": "high",
      "dependencies": [
        2
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 5,
      "title": "Login Experience Implementation",
      "description": "Replace the current login form with MSAL login button and implement popup-based login experience with silent authentication for returning users.",
      "details": "1. Create a Login page component (src/pages/Login.tsx):\n```typescript\nimport React, { useEffect, useState } from 'react';\nimport { useNavigate, useLocation } from 'react-router-dom';\nimport { useAuth } from '../auth/AuthContext';\n\nconst Login: React.FC = () => {\n  const { login, isAuthenticated, isLoading, error } = useAuth();\n  const navigate = useNavigate();\n  const location = useLocation();\n  const [loginError, setLoginError] = useState<string | null>(null);\n  \n  // Get the intended destination from location state or default to home\n  const from = (location.state as any)?.from?.pathname || '/';\n  \n  useEffect(() => {\n    // If already authenticated, redirect to the intended destination\n    if (isAuthenticated) {\n      navigate(from, { replace: true });\n    }\n  }, [isAuthenticated, navigate, from]);\n  \n  const handleLogin = async () => {\n    try {\n      setLoginError(null);\n      await login();\n      // Navigation will happen in the useEffect above once isAuthenticated updates\n    } catch (err) {\n      setLoginError('Login failed. Please try again.');\n      console.error('Login error:', err);\n    }\n  };\n  \n  return (\n    <div className=\"login-container\">\n      <div className=\"login-card\">\n        <img src=\"/logo.png\" alt=\"FourSPM Logo\" className=\"login-logo\" />\n        <h1>Welcome to FourSPM</h1>\n        <p>Please sign in with your Microsoft account to continue.</p>\n        \n        {loginError && (\n          <div className=\"error-message\">{loginError}</div>\n        )}\n        \n        {error && (\n          <div className=\"error-message\">{error.message}</div>\n        )}\n        \n        <button \n          className=\"ms-login-button\" \n          onClick={handleLogin}\n          disabled={isLoading}\n        >\n          {isLoading ? 'Signing in...' : 'Sign in with Microsoft'}\n        </button>\n      </div>\n    </div>\n  );\n};\n\nexport default Login;\n```\n\n2. Create styles for the login page (src/styles/login.css):\n```css\n.login-container {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  min-height: 100vh;\n  background-color: #f5f5f5;\n}\n\n.login-card {\n  width: 100%;\n  max-width: 400px;\n  padding: 2rem;\n  background: white;\n  border-radius: 8px;\n  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);\n  text-align: center;\n}\n\n.login-logo {\n  width: 120px;\n  margin-bottom: 1.5rem;\n}\n\n.ms-login-button {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  width: 100%;\n  padding: 0.75rem 1rem;\n  margin-top: 1.5rem;\n  background-color: #0078d4;\n  color: white;\n  border: none;\n  border-radius: 4px;\n  font-size: 1rem;\n  cursor: pointer;\n  transition: background-color 0.2s;\n}\n\n.ms-login-button:hover {\n  background-color: #106ebe;\n}\n\n.ms-login-button:disabled {\n  background-color: #ccc;\n  cursor: not-allowed;\n}\n\n.error-message {\n  color: #d83b01;\n  margin: 1rem 0;\n  padding: 0.5rem;\n  background-color: #fde7e9;\n  border-radius: 4px;\n}\n```\n\n3. Implement silent authentication in the main App component (src/App.tsx):\n```typescript\nimport React, { useEffect } from 'react';\nimport { useMsal } from '@azure/msal-react';\nimport { loginRequest } from './auth/msalConfig';\n\nfunction App() {\n  const { instance, accounts } = useMsal();\n  \n  useEffect(() => {\n    // Attempt silent authentication if there's an account\n    const attemptSilentAuth = async () => {\n      if (accounts.length > 0) {\n        try {\n          await instance.acquireTokenSilent({\n            ...loginRequest,\n            account: accounts[0]\n          });\n        } catch (error) {\n          console.error('Silent authentication failed:', error);\n          // Silent auth failed, but we don't need to do anything here\n          // The user will be redirected to login if they try to access a protected route\n        }\n      }\n    };\n    \n    attemptSilentAuth();\n  }, [instance, accounts]);\n  \n  // Rest of your App component\n}\n```\n\n4. Create a loading indicator component (src/components/LoadingSpinner.tsx):\n```typescript\nimport React from 'react';\nimport '../styles/loading-spinner.css';\n\ninterface LoadingSpinnerProps {\n  message?: string;\n}\n\nconst LoadingSpinner: React.FC<LoadingSpinnerProps> = ({ message = 'Loading...' }) => {\n  return (\n    <div className=\"loading-spinner-container\">\n      <div className=\"loading-spinner\"></div>\n      <p>{message}</p>\n    </div>\n  );\n};\n\nexport default LoadingSpinner;\n```",
      "testStrategy": "1. Create unit tests for the Login component using React Testing Library\n2. Test the login button functionality and verify it calls the login function\n3. Test redirection after successful authentication\n4. Verify error handling and error message display\n5. Test silent authentication for returning users\n6. Test the loading state during authentication\n7. Verify that the login page is responsive and displays correctly on different screen sizes\n8. Test accessibility of the login page (keyboard navigation, screen reader compatibility)",
      "priority": "high",
      "dependencies": [
        1,
        2
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 6,
      "title": "Role Management Interface",
      "description": "Create an administrative interface for viewing and managing roles with a grid for viewing, adding, editing, and deleting roles.",
      "details": "1. Create a Role Management page (src/pages/RoleManagement.tsx):\n```typescript\nimport React, { useEffect, useState } from 'react';\nimport { useNavigate } from 'react-router-dom';\nimport { DataGrid, Column, Editing, Paging, Filtering, Sorting } from 'devextreme-react/data-grid';\nimport { Button } from 'devextreme-react/button';\nimport { useApi } from '../hooks/useApi';\nimport LoadingSpinner from '../components/LoadingSpinner';\n\ninterface Role {\n  id: number;\n  name: string;\n  description: string;\n  createdDate: string;\n  modifiedDate: string;\n}\n\nconst RoleManagement: React.FC = () => {\n  const { data: roles, loading, error, get, post, put, delete: deleteRole } = useApi<Role[]>();\n  const [refreshTrigger, setRefreshTrigger] = useState(0);\n  const navigate = useNavigate();\n  \n  useEffect(() => {\n    get('/api/roles');\n  }, [get, refreshTrigger]);\n  \n  const handleRowInserting = async (e: any) => {\n    try {\n      await post('/api/roles', e.data);\n      setRefreshTrigger(prev => prev + 1);\n    } catch (error) {\n      console.error('Error creating role:', error);\n      e.cancel = true;\n    }\n  };\n  \n  const handleRowUpdating = async (e: any) => {\n    try {\n      const roleId = e.key;\n      await put(`/api/roles/${roleId}`, { ...e.oldData, ...e.newData });\n      setRefreshTrigger(prev => prev + 1);\n    } catch (error) {\n      console.error('Error updating role:', error);\n      e.cancel = true;\n    }\n  };\n  \n  const handleRowRemoving = async (e: any) => {\n    try {\n      const roleId = e.key;\n      await deleteRole(`/api/roles/${roleId}`);\n      setRefreshTrigger(prev => prev + 1);\n    } catch (error) {\n      console.error('Error deleting role:', error);\n      e.cancel = true;\n    }\n  };\n  \n  const handleManagePermissions = (roleId: number) => {\n    navigate(`/roles/${roleId}/permissions`);\n  };\n  \n  if (loading && !roles) {\n    return <LoadingSpinner message=\"Loading roles...\" />;\n  }\n  \n  if (error) {\n    return (\n      <div className=\"error-container\">\n        <h2>Error loading roles</h2>\n        <p>{error.message}</p>\n        <Button text=\"Retry\" onClick={() => setRefreshTrigger(prev => prev + 1)} />\n      </div>\n    );\n  }\n  \n  return (\n    <div className=\"role-management-container\">\n      <h1>Role Management</h1>\n      \n      <DataGrid\n        dataSource={roles || []}\n        keyExpr=\"id\"\n        showBorders={true}\n        onRowInserting={handleRowInserting}\n        onRowUpdating={handleRowUpdating}\n        onRowRemoving={handleRowRemoving}\n      >\n        <Paging defaultPageSize={10} />\n        <Filtering />\n        <Sorting mode=\"multiple\" />\n        \n        <Editing\n          mode=\"popup\"\n          allowAdding={true}\n          allowUpdating={true}\n          allowDeleting={true}\n          useIcons={true}\n        />\n        \n        <Column dataField=\"id\" caption=\"ID\" allowEditing={false} width={80} />\n        <Column dataField=\"name\" caption=\"Role Name\" />\n        <Column dataField=\"description\" caption=\"Description\" />\n        <Column dataField=\"createdDate\" caption=\"Created Date\" dataType=\"date\" allowEditing={false} />\n        <Column dataField=\"modifiedDate\" caption=\"Modified Date\" dataType=\"date\" allowEditing={false} />\n        <Column type=\"buttons\" width={110} />\n        \n        <Column caption=\"Actions\" type=\"buttons\" width={120}>\n          <Button\n            hint=\"Manage Permissions\"\n            icon=\"key\"\n            onClick={(e: any) => handleManagePermissions(e.row.data.id)}\n          />\n        </Column>\n      </DataGrid>\n    </div>\n  );\n};\n\nexport default RoleManagement;\n```\n\n2. Create styles for the Role Management page (src/styles/role-management.css):\n```css\n.role-management-container {\n  padding: 1.5rem;\n}\n\n.role-management-container h1 {\n  margin-bottom: 1.5rem;\n  color: #333;\n}\n\n.error-container {\n  padding: 2rem;\n  text-align: center;\n  background-color: #fde7e9;\n  border-radius: 8px;\n  margin: 2rem;\n}\n\n.error-container h2 {\n  color: #d83b01;\n  margin-bottom: 1rem;\n}\n\n.error-container button {\n  margin-top: 1rem;\n}\n```\n\n3. Create a service for role management (src/services/roleService.ts):\n```typescript\nimport apiService from './apiService';\n\nexport interface Role {\n  id: number;\n  name: string;\n  description: string;\n  createdDate: string;\n  modifiedDate: string;\n}\n\nclass RoleService {\n  async getRoles(): Promise<Role[]> {\n    return apiService.get<Role[]>('/api/roles');\n  }\n  \n  async getRole(id: number): Promise<Role> {\n    return apiService.get<Role>(`/api/roles/${id}`);\n  }\n  \n  async createRole(role: Omit<Role, 'id' | 'createdDate' | 'modifiedDate'>): Promise<Role> {\n    return apiService.post<Role>('/api/roles', role);\n  }\n  \n  async updateRole(id: number, role: Partial<Omit<Role, 'id' | 'createdDate' | 'modifiedDate'>>): Promise<Role> {\n    return apiService.put<Role>(`/api/roles/${id}`, role);\n  }\n  \n  async deleteRole(id: number): Promise<void> {\n    return apiService.delete<void>(`/api/roles/${id}`);\n  }\n}\n\nexport const roleService = new RoleService();\n```",
      "testStrategy": "1. Create unit tests for the RoleManagement component using React Testing Library\n2. Mock API responses for role data\n3. Test the grid initialization and data loading\n4. Test CRUD operations (Create, Read, Update, Delete) for roles\n5. Verify that error handling works correctly\n6. Test navigation to the permission management page\n7. Verify that the grid displays and filters data correctly\n8. Test form validation for adding and editing roles",
      "priority": "medium",
      "dependencies": [
        3,
        4
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 7,
      "title": "Permission Management Interface",
      "description": "Create an interface for assigning permissions to roles with a categorized list of available permissions and functionality to update and save permissions.",
      "status": "done",
      "dependencies": [
        6
      ],
      "priority": "medium",
      "details": "1. Create a Permission Management page (src/pages/PermissionManagement.tsx):\n```typescript\nimport React, { useEffect, useState } from 'react';\nimport { useParams, useNavigate } from 'react-router-dom';\nimport { Button } from 'devextreme-react/button';\nimport { TreeView } from 'devextreme-react/tree-view';\nimport { useApi } from '../hooks/useApi';\nimport LoadingSpinner from '../components/LoadingSpinner';\n\ninterface Permission {\n  id: number;\n  name: string;\n  description: string;\n  category: string;\n}\n\ninterface Role {\n  id: number;\n  name: string;\n  description: string;\n}\n\ninterface RolePermission {\n  roleId: number;\n  permissionId: number;\n}\n\ninterface PermissionNode {\n  id: string;\n  text: string;\n  expanded?: boolean;\n  selected?: boolean;\n  items?: PermissionNode[];\n  permissionId?: number;\n}\n\nconst PermissionManagement: React.FC = () => {\n  const { roleId } = useParams<{ roleId: string }>();\n  const navigate = useNavigate();\n  const [role, setRole] = useState<Role | null>(null);\n  const [permissionTree, setPermissionTree] = useState<PermissionNode[]>([]);\n  const [selectedPermissions, setSelectedPermissions] = useState<number[]>([]);\n  const [saving, setSaving] = useState(false);\n  const [saveError, setSaveError] = useState<string | null>(null);\n  const [saveSuccess, setSaveSuccess] = useState(false);\n  \n  const { get: getRole, loading: loadingRole, error: roleError } = useApi<Role>();\n  const { get: getPermissions, loading: loadingPermissions, error: permissionsError } = useApi<Permission[]>();\n  const { get: getRolePermissions, loading: loadingRolePermissions, error: rolePermissionsError } = useApi<RolePermission[]>();\n  const { post: saveRolePermissions } = useApi<void>();\n  \n  // Load role data\n  useEffect(() => {\n    if (roleId) {\n      getRole(`/api/roles/${roleId}`);\n    }\n  }, [getRole, roleId]);\n  \n  // Set role when data is loaded\n  useEffect(() => {\n    if (getRole.data) {\n      setRole(getRole.data);\n    }\n  }, [getRole.data]);\n  \n  // Load permissions and role permissions\n  useEffect(() => {\n    if (roleId) {\n      getPermissions('/api/permissions');\n      getRolePermissions(`/api/roles/${roleId}/permissions`);\n    }\n  }, [getPermissions, getRolePermissions, roleId]);\n  \n  // Build permission tree and set selected permissions\n  useEffect(() => {\n    if (getPermissions.data && getRolePermissions.data) {\n      const permissions = getPermissions.data;\n      const rolePermissions = getRolePermissions.data;\n      \n      // Get selected permission IDs\n      const selectedIds = rolePermissions.map(rp => rp.permissionId);\n      setSelectedPermissions(selectedIds);\n      \n      // Group permissions by category\n      const categories = [...new Set(permissions.map(p => p.category))];\n      \n      // Build tree structure\n      const tree = categories.map(category => {\n        const categoryPermissions = permissions\n          .filter(p => p.category === category)\n          .map(p => ({\n            id: `permission-${p.id}`,\n            text: p.name,\n            selected: selectedIds.includes(p.id),\n            permissionId: p.id\n          }));\n        \n        return {\n          id: `category-${category}`,\n          text: category,\n          expanded: true,\n          items: categoryPermissions\n        };\n      });\n      \n      setPermissionTree(tree);\n    }\n  }, [getPermissions.data, getRolePermissions.data]);\n  \n  const handleSelectionChanged = (e: any) => {\n    const selectedItems = e.component.getSelectedNodes();\n    const permissionIds = selectedItems\n      .filter((node: any) => node.itemData.permissionId)\n      .map((node: any) => node.itemData.permissionId);\n    \n    setSelectedPermissions(permissionIds);\n  };\n  \n  const handleSave = async () => {\n    if (!roleId) return;\n    \n    setSaving(true);\n    setSaveError(null);\n    setSaveSuccess(false);\n    \n    try {\n      await saveRolePermissions(`/api/roles/${roleId}/permissions`, { permissionIds: selectedPermissions });\n      setSaveSuccess(true);\n      \n      // Reset success message after 3 seconds\n      setTimeout(() => setSaveSuccess(false), 3000);\n    } catch (error) {\n      setSaveError('Failed to save permissions. Please try again.');\n      console.error('Error saving permissions:', error);\n    } finally {\n      setSaving(false);\n    }\n  };\n  \n  const handleCancel = () => {\n    navigate('/roles');\n  };\n  \n  const isLoading = loadingRole || loadingPermissions || loadingRolePermissions;\n  const error = roleError || permissionsError || rolePermissionsError;\n  \n  if (isLoading && (!role || permissionTree.length === 0)) {\n    return <LoadingSpinner message=\"Loading permissions...\" />;\n  }\n  \n  if (error) {\n    return (\n      <div className=\"error-container\">\n        <h2>Error loading permissions</h2>\n        <p>{error.message}</p>\n        <Button text=\"Back to Roles\" onClick={handleCancel} />\n      </div>\n    );\n  }\n  \n  return (\n    <div className=\"permission-management-container\">\n      <h1>Manage Permissions for {role?.name}</h1>\n      <p className=\"role-description\">{role?.description}</p>\n      \n      {saveSuccess && (\n        <div className=\"success-message\">Permissions saved successfully!</div>\n      )}\n      \n      {saveError && (\n        <div className=\"error-message\">{saveError}</div>\n      )}\n      \n      <div className=\"permission-tree-container\">\n        <TreeView\n          items={permissionTree}\n          width=\"100%\"\n          height={500}\n          showCheckBoxesMode=\"normal\"\n          onSelectionChanged={handleSelectionChanged}\n          selectNodesRecursive={false}\n          selectByClick={true}\n        />\n      </div>\n      \n      <div className=\"action-buttons\">\n        <Button\n          text=\"Save\"\n          type=\"success\"\n          onClick={handleSave}\n          disabled={saving}\n        />\n        <Button\n          text=\"Cancel\"\n          onClick={handleCancel}\n          disabled={saving}\n        />\n      </div>\n    </div>\n  );\n};\n\nexport default PermissionManagement;\n```\n\n2. Create styles for the Permission Management page (src/styles/permission-management.css):\n```css\n.permission-management-container {\n  padding: 1.5rem;\n}\n\n.permission-management-container h1 {\n  margin-bottom: 0.5rem;\n  color: #333;\n}\n\n.role-description {\n  margin-bottom: 1.5rem;\n  color: #666;\n}\n\n.permission-tree-container {\n  margin: 1.5rem 0;\n  border: 1px solid #e0e0e0;\n  border-radius: 4px;\n  padding: 1rem;\n  background-color: #f9f9f9;\n}\n\n.action-buttons {\n  display: flex;\n  gap: 1rem;\n  margin-top: 1.5rem;\n}\n\n.success-message {\n  background-color: #e6f7e6;\n  color: #107c10;\n  padding: 0.75rem 1rem;\n  border-radius: 4px;\n  margin: 1rem 0;\n}\n\n.error-message {\n  background-color: #fde7e9;\n  color: #d83b01;\n  padding: 0.75rem 1rem;\n  border-radius: 4px;\n  margin: 1rem 0;\n}\n```\n\n3. Create a service for permission management (src/services/permissionService.ts):\n```typescript\nimport apiService from './apiService';\n\nexport interface Permission {\n  id: number;\n  name: string;\n  description: string;\n  category: string;\n}\n\nexport interface RolePermission {\n  roleId: number;\n  permissionId: number;\n}\n\nclass PermissionService {\n  async getPermissions(): Promise<Permission[]> {\n    return apiService.get<Permission[]>('/api/permissions');\n  }\n  \n  async getRolePermissions(roleId: number): Promise<RolePermission[]> {\n    return apiService.get<RolePermission[]>(`/api/roles/${roleId}/permissions`);\n  }\n  \n  async saveRolePermissions(roleId: number, permissionIds: number[]): Promise<void> {\n    return apiService.post<void>(`/api/roles/${roleId}/permissions`, { permissionIds });\n  }\n}\n\nexport const permissionService = new PermissionService();\n```\n\n4. Add a permission management button to the role grid (src/components/RoleGrid.tsx):\n```typescript\n// Add this to the imports\nimport { Button } from 'devextreme-react/button';\nimport { useNavigate } from 'react-router-dom';\n\n// Add this to the RoleGrid component\nconst navigate = useNavigate();\n\nconst handleManagePermissions = (roleId: number) => {\n  navigate(`/roles/${roleId}/permissions`);\n};\n\n// Add this to the grid columns configuration\n{\n  type: 'buttons',\n  width: 110,\n  buttons: [\n    {\n      hint: 'Manage Permissions',\n      icon: 'key',\n      onClick: (e: any) => handleManagePermissions(e.row.data.id)\n    },\n    // ... other existing buttons\n  ]\n}\n```\n\n5. Update the routes configuration to include the permission management page (src/routes.tsx):\n```typescript\nimport PermissionManagement from './pages/PermissionManagement';\n\n// Add this to your routes array\n{\n  path: '/roles/:roleId/permissions',\n  element: <PermissionManagement />\n}\n```\n\n6. Create a backend endpoint for permissions in RolesController.cs:\n```csharp\n[HttpGet(\"api/permissions\")]\npublic IActionResult GetAllPermissions()\n{\n    // Return the static list of permissions if no custom permissions exist\n    var permissions = _context.Permissions.ToList();\n    \n    if (!permissions.Any())\n    {\n        // Use the static permission list defined in the controller\n        permissions = new List<Permission>\n        {\n            new Permission { Id = 1, Name = \"ViewUsers\", Description = \"View user accounts\", Category = \"User Management\" },\n            new Permission { Id = 2, Name = \"CreateUsers\", Description = \"Create new user accounts\", Category = \"User Management\" },\n            new Permission { Id = 3, Name = \"EditUsers\", Description = \"Edit existing user accounts\", Category = \"User Management\" },\n            new Permission { Id = 4, Name = \"DeleteUsers\", Description = \"Delete user accounts\", Category = \"User Management\" },\n            new Permission { Id = 5, Name = \"ViewRoles\", Description = \"View roles\", Category = \"Role Management\" },\n            new Permission { Id = 6, Name = \"CreateRoles\", Description = \"Create new roles\", Category = \"Role Management\" },\n            new Permission { Id = 7, Name = \"EditRoles\", Description = \"Edit existing roles\", Category = \"Role Management\" },\n            new Permission { Id = 8, Name = \"DeleteRoles\", Description = \"Delete roles\", Category = \"Role Management\" },\n            new Permission { Id = 9, Name = \"AssignRoles\", Description = \"Assign roles to users\", Category = \"Role Management\" },\n            // Add more permissions as needed\n        };\n    }\n    \n    return Ok(permissions);\n}\n\n[HttpGet(\"api/roles/{roleId}/permissions\")]\npublic IActionResult GetRolePermissions(int roleId)\n{\n    var role = _context.Roles.Find(roleId);\n    if (role == null)\n    {\n        return NotFound();\n    }\n    \n    var rolePermissions = _context.RolePermissions\n        .Where(rp => rp.RoleId == roleId)\n        .ToList();\n    \n    return Ok(rolePermissions);\n}\n\n[HttpPost(\"api/roles/{roleId}/permissions\")]\npublic IActionResult SaveRolePermissions(int roleId, [FromBody] SavePermissionsRequest request)\n{\n    var role = _context.Roles.Find(roleId);\n    if (role == null)\n    {\n        return NotFound();\n    }\n    \n    // Remove existing permissions\n    var existingPermissions = _context.RolePermissions\n        .Where(rp => rp.RoleId == roleId)\n        .ToList();\n    \n    _context.RolePermissions.RemoveRange(existingPermissions);\n    \n    // Add new permissions\n    foreach (var permissionId in request.PermissionIds)\n    {\n        _context.RolePermissions.Add(new RolePermission\n        {\n            RoleId = roleId,\n            PermissionId = permissionId\n        });\n    }\n    \n    _context.SaveChanges();\n    \n    return Ok();\n}\n\npublic class SavePermissionsRequest\n{\n    public List<int> PermissionIds { get; set; }\n}\n```\n\n7. Create the database models for permissions (if not already existing):\n```csharp\npublic class Permission\n{\n    public int Id { get; set; }\n    public string Name { get; set; }\n    public string Description { get; set; }\n    public string Category { get; set; }\n}\n\npublic class RolePermission\n{\n    public int Id { get; set; }\n    public int RoleId { get; set; }\n    public int PermissionId { get; set; }\n    \n    public Role Role { get; set; }\n    public Permission Permission { get; set; }\n}\n```",
      "testStrategy": "1. Create unit tests for the PermissionManagement component using React Testing Library\n2. Mock API responses for permission data\n3. Test the tree view initialization and data loading\n4. Test permission selection and deselection\n5. Test saving permissions and verify API calls\n6. Verify error handling for API failures\n7. Test navigation back to the roles page\n8. Verify that success and error messages are displayed correctly\n9. Test the permission management button in the role grid\n10. Verify that clicking the permission button navigates to the correct URL\n11. Test the backend endpoints for retrieving and saving permissions\n12. Verify that the static permission list is used when no custom permissions exist\n13. Test adding and removing permissions for a role",
      "subtasks": [
        {
          "id": 1,
          "title": "Define Permission Types and Structure",
          "description": "Identify and categorize all permission types needed in the system, creating a hierarchical structure for the tree view.",
          "dependencies": [],
          "details": "Determine the different permission categories, individual permissions within each category, and their relationships. Create a data model that supports inheritance and hierarchical representation. Define permission attributes such as read, write, execute levels for each resource.",
          "status": "done"
        },
        {
          "id": 2,
          "title": "Design and Implement Permission Service",
          "description": "Create a backend service to handle permission operations including fetching, updating, and validating permissions.",
          "dependencies": [
            1
          ],
          "details": "Develop API endpoints for CRUD operations on permissions. Implement efficient algorithms for permission checks and validation. Create methods for batch operations to optimize performance. Include caching mechanisms to reduce database load for frequently accessed permissions.",
          "status": "done"
        },
        {
          "id": 3,
          "title": "Develop Tree View Component for Permission UI",
          "description": "Build a responsive tree view component that displays the hierarchical permission structure with selection capabilities.",
          "dependencies": [
            1
          ],
          "details": "Implement an expandable/collapsible tree structure that visually represents permission categories and individual permissions. Add checkboxes for selection with support for partial selection states. Ensure the component handles large permission sets efficiently with virtualization if needed.",
          "status": "done"
        },
        {
          "id": 4,
          "title": "Implement Permission Selection and Update Logic",
          "description": "Create the logic to handle user interactions with the permission tree, including selection propagation and change tracking.",
          "dependencies": [
            3
          ],
          "details": "Implement cascading selection logic where selecting a parent automatically selects children. Add logic to handle partial selection states. Create a change tracking mechanism to identify modified permissions. Implement undo/redo functionality for selection changes.",
          "status": "done"
        },
        {
          "id": 5,
          "title": "Integrate with Role Management System",
          "description": "Connect the permission management system with the existing role-based access control framework.",
          "dependencies": [
            2,
            4
          ],
          "details": "Create interfaces to associate roles with permission sets. Implement role-based permission inheritance. Add functionality to view and modify permissions by role. Ensure changes to roles properly update associated permissions and vice versa.",
          "status": "done"
        },
        {
          "id": 6,
          "title": "Implement Loading and Saving States",
          "description": "Add state management for loading permissions and saving changes with appropriate user feedback.",
          "dependencies": [
            4,
            5
          ],
          "details": "Implement loading indicators during permission fetching and updates. Create optimistic UI updates with rollback capability on failure. Add confirmation dialogs for significant permission changes. Implement periodic auto-saving of permission changes to prevent data loss.",
          "status": "done"
        },
        {
          "id": 7,
          "title": "Develop Comprehensive Error Handling",
          "description": "Implement robust error handling throughout the permission management system.",
          "dependencies": [
            2,
            6
          ],
          "details": "Create meaningful error messages for different failure scenarios. Implement retry mechanisms for transient errors. Add logging for debugging purposes. Create recovery paths for common error situations to prevent data loss or inconsistent states.",
          "status": "done"
        },
        {
          "id": 8,
          "title": "Add Permission Management Button to Role Grid",
          "description": "Add a button in the role grid that opens the permissions interface for a selected role.",
          "dependencies": [
            5
          ],
          "details": "Implement a button in the role grid similar to the one in variation-columns.ts. Configure the button to navigate to the permission management page for the selected role. Add appropriate styling and tooltips for the button.",
          "status": "done"
        },
        {
          "id": 9,
          "title": "Create Backend Endpoint for Permissions",
          "description": "Implement an endpoint to retrieve all available permissions and handle role-specific permission operations.",
          "dependencies": [
            2
          ],
          "details": "Create an API endpoint that returns all available permissions. Implement logic to use static permission list from RolesController.cs if no custom permissions exist. Create endpoints for retrieving and updating role-specific permissions.",
          "status": "done"
        },
        {
          "id": 10,
          "title": "Implement ROLE_PERMISSION Table Integration",
          "description": "Create functionality to add and remove entries in the ROLE_PERMISSION table when permissions are assigned or unassigned.",
          "dependencies": [
            5,
            9
          ],
          "details": "Implement logic to add entries to the ROLE_PERMISSION table when a permission is checked. Create functionality to remove entries when permissions are unchecked. Ensure proper database transaction handling to maintain data integrity.",
          "status": "done"
        }
      ]
    },
    {
      "id": 8,
      "title": "Error Handling and Feedback",
      "description": "Implement comprehensive error handling for authentication failures and provide user-friendly feedback throughout the authentication flow.",
      "details": "1. Create a Toast notification component (src/components/Toast.tsx):\n```typescript\nimport React, { useState, useEffect } from 'react';\nimport '../styles/toast.css';\n\nexport type ToastType = 'success' | 'error' | 'info' | 'warning';\n\ninterface ToastProps {\n  message: string;\n  type: ToastType;\n  duration?: number;\n  onClose?: () => void;\n}\n\nconst Toast: React.FC<ToastProps> = ({ \n  message, \n  type, \n  duration = 5000, \n  onClose \n}) => {\n  const [visible, setVisible] = useState(true);\n  \n  useEffect(() => {\n    const timer = setTimeout(() => {\n      setVisible(false);\n      if (onClose) onClose();\n    }, duration);\n    \n    return () => clearTimeout(timer);\n  }, [duration, onClose]);\n  \n  const handleClose = () => {\n    setVisible(false);\n    if (onClose) onClose();\n  };\n  \n  if (!visible) return null;\n  \n  return (\n    <div className={`toast toast-${type}`}>\n      <div className=\"toast-content\">\n        <span className=\"toast-message\">{message}</span>\n      </div>\n      <button className=\"toast-close\" onClick={handleClose}>\n        ×\n      </button>\n    </div>\n  );\n};\n\nexport default Toast;\n```\n\n2. Create a Toast container to manage multiple toasts (src/components/ToastContainer.tsx):\n```typescript\nimport React, { useState, useCallback } from 'react';\nimport Toast, { ToastType } from './Toast';\nimport '../styles/toast-container.css';\n\nexport interface ToastMessage {\n  id: string;\n  message: string;\n  type: ToastType;\n  duration?: number;\n}\n\ninterface ToastContextType {\n  showToast: (message: string, type: ToastType, duration?: number) => void;\n}\n\nexport const ToastContext = React.createContext<ToastContextType | undefined>(undefined);\n\nexport const ToastProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {\n  const [toasts, setToasts] = useState<ToastMessage[]>([]);\n  \n  const showToast = useCallback((message: string, type: ToastType, duration = 5000) => {\n    const id = Date.now().toString();\n    setToasts(prev => [...prev, { id, message, type, duration }]);\n  }, []);\n  \n  const removeToast = useCallback((id: string) => {\n    setToasts(prev => prev.filter(toast => toast.id !== id));\n  }, []);\n  \n  return (\n    <ToastContext.Provider value={{ showToast }}>\n      {children}\n      <div className=\"toast-container\">\n        {toasts.map(toast => (\n          <Toast\n            key={toast.id}\n            message={toast.message}\n            type={toast.type}\n            duration={toast.duration}\n            onClose={() => removeToast(toast.id)}\n          />\n        ))}\n      </div>\n    </ToastContext.Provider>\n  );\n};\n\nexport const useToast = (): ToastContextType => {\n  const context = React.useContext(ToastContext);\n  if (context === undefined) {\n    throw new Error('useToast must be used within a ToastProvider');\n  }\n  return context;\n};\n```\n\n3. Create styles for toasts (src/styles/toast.css):\n```css\n.toast {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  padding: 0.75rem 1rem;\n  border-radius: 4px;\n  margin-bottom: 0.5rem;\n  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n  animation: toast-in 0.3s ease-out;\n  max-width: 350px;\n  width: 100%;\n}\n\n.toast-success {\n  background-color: #e6f7e6;\n  color: #107c10;\n  border-left: 4px solid #107c10;\n}\n\n.toast-error {\n  background-color: #fde7e9;\n  color: #d83b01;\n  border-left: 4px solid #d83b01;\n}\n\n.toast-info {\n  background-color: #e5f0fd;\n  color: #0078d4;\n  border-left: 4px solid #0078d4;\n}\n\n.toast-warning {\n  background-color: #fff4ce;\n  color: #9d5d00;\n  border-left: 4px solid #9d5d00;\n}\n\n.toast-content {\n  flex: 1;\n}\n\n.toast-message {\n  font-size: 0.875rem;\n}\n\n.toast-close {\n  background: none;\n  border: none;\n  font-size: 1.25rem;\n  cursor: pointer;\n  margin-left: 0.5rem;\n  padding: 0;\n  color: inherit;\n  opacity: 0.7;\n}\n\n.toast-close:hover {\n  opacity: 1;\n}\n\n@keyframes toast-in {\n  from {\n    transform: translateY(20px);\n    opacity: 0;\n  }\n  to {\n    transform: translateY(0);\n    opacity: 1;\n  }\n}\n```\n\n4. Create styles for the toast container (src/styles/toast-container.css):\n```css\n.toast-container {\n  position: fixed;\n  bottom: 1rem;\n  right: 1rem;\n  z-index: 9999;\n  display: flex;\n  flex-direction: column;\n  align-items: flex-end;\n}\n```\n\n5. Update the AuthContext to use toast notifications (src/auth/AuthContext.tsx):\n```typescript\nimport { useToast } from '../components/ToastContainer';\n\nexport const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {\n  // ... existing code\n  \n  const { showToast } = useToast();\n  \n  const login = async () => {\n    try {\n      await instance.loginPopup(loginRequest);\n    } catch (err) {\n      const error = err as Error;\n      setError(error);\n      \n      // Show appropriate error message based on error type\n      if (error.message.includes('user_cancelled')) {\n        showToast('Login was cancelled.', 'info');\n      } else if (error.message.includes('interaction_in_progress')) {\n        showToast('Another login attempt is in progress.', 'warning');\n      } else {\n        showToast(`Login failed: ${error.message}`, 'error');\n      }\n    }\n  };\n  \n  const logout = async () => {\n    try {\n      await instance.logoutPopup();\n      showToast('You have been successfully logged out.', 'success');\n    } catch (err) {\n      const error = err as Error;\n      setError(error);\n      showToast(`Logout failed: ${error.message}`, 'error');\n    }\n  };\n  \n  // ... rest of the component\n};\n```\n\n6. Create an error boundary component (src/components/ErrorBoundary.tsx):\n```typescript\nimport React, { Component, ErrorInfo, ReactNode } from 'react';\n\ninterface Props {\n  children: ReactNode;\n  fallback?: ReactNode;\n}\n\ninterface State {\n  hasError: boolean;\n  error: Error | null;\n}\n\nclass ErrorBoundary extends Component<Props, State> {\n  constructor(props: Props) {\n    super(props);\n    this.state = { hasError: false, error: null };\n  }\n\n  static getDerivedStateFromError(error: Error): State {\n    return { hasError: true, error };\n  }\n\n  componentDidCatch(error: Error, errorInfo: ErrorInfo): void {\n    console.error('Error caught by boundary:', error, errorInfo);\n    // You could also log to an error reporting service here\n  }\n\n  render(): ReactNode {\n    if (this.state.hasError) {\n      if (this.props.fallback) {\n        return this.props.fallback;\n      }\n      \n      return (\n        <div className=\"error-boundary\">\n          <h2>Something went wrong</h2>\n          <p>We apologize for the inconvenience. Please try refreshing the page.</p>\n          <details>\n            <summary>Error details</summary>\n            <pre>{this.state.error?.toString()}</pre>\n          </details>\n          <button onClick={() => window.location.reload()}>Refresh Page</button>\n        </div>\n      );\n    }\n\n    return this.props.children;\n  }\n}\n\nexport default ErrorBoundary;\n```\n\n7. Add the ErrorBoundary and ToastProvider to the App component:\n```typescript\nimport { ErrorBoundary } from './components/ErrorBoundary';\nimport { ToastProvider } from './components/ToastContainer';\n\nfunction App() {\n  return (\n    <ErrorBoundary>\n      <ToastProvider>\n        {/* Rest of your application */}\n      </ToastProvider>\n    </ErrorBoundary>\n  );\n}\n```",
      "testStrategy": "1. Create unit tests for the Toast and ToastContainer components\n2. Test different toast types (success, error, info, warning)\n3. Verify that toasts automatically disappear after the specified duration\n4. Test the ErrorBoundary component by intentionally causing errors\n5. Verify that authentication errors are properly caught and displayed\n6. Test error handling in the API service\n7. Verify that appropriate error messages are shown for different authentication failure scenarios\n8. Test accessibility of error messages and notifications",
      "priority": "medium",
      "dependencies": [
        2,
        3,
        5
      ],
      "status": "done",
      "subtasks": [
        {
          "id": 1,
          "title": "Implement Toast Component",
          "description": "Create a reusable Toast notification component with support for different types (success, error, warning, info)",
          "dependencies": [],
          "details": "Create a Toast.js file in the components folder with styling support for different notification types. Include icons, message display, and auto-dismiss functionality using useState and useEffect hooks. Support customizable duration and animation effects.",
          "status": "done"
        },
        {
          "id": 2,
          "title": "Build ToastContainer and Context",
          "description": "Develop a container component and context to manage multiple toast notifications",
          "dependencies": [
            1
          ],
          "details": "Create a ToastContext using React Context API to manage the state of all active notifications. Implement methods for adding, removing, and updating toasts. Build a ToastContainer component that renders all active toast notifications with proper positioning and stacking.",
          "status": "done"
        },
        {
          "id": 3,
          "title": "Implement NetworkDetector Service",
          "description": "Create a service to detect and handle network connectivity changes",
          "dependencies": [],
          "details": "Develop a NetworkDetector that uses the browser's online/offline events to monitor connectivity. Implement debouncing to prevent rapid state changes. Create hooks or context to expose network status to components that need this information.",
          "status": "done"
        },
        {
          "id": 4,
          "title": "Enhance AuthContext for Token Refresh",
          "description": "Update authentication context to handle token expiration and refresh",
          "dependencies": [
            2
          ],
          "details": "Modify the existing AuthContext to include token refresh logic. Implement interceptors to catch 401 errors and attempt token refresh before retrying the original request. Integrate with ToastContext to show appropriate notifications for authentication issues.",
          "status": "done"
        },
        {
          "id": 5,
          "title": "Update API Service for Error Handling",
          "description": "Enhance API service layer to handle various error types and network issues",
          "dependencies": [
            3,
            4
          ],
          "details": "Implement comprehensive error handling in the API service layer. Create error categorization (network, authentication, permission, validation, server). Add retry logic for transient errors and integrate with NetworkDetector to handle offline scenarios.",
          "status": "done"
        },
        {
          "id": 6,
          "title": "Integrate Providers in App Component",
          "description": "Connect all context providers in the main App component",
          "dependencies": [
            2,
            3,
            4,
            5
          ],
          "details": "Update the App component to properly nest all context providers (Toast, Auth, Network) in the correct order. Ensure proper dependency flow and test the integration of all providers together.",
          "status": "done"
        },
        {
          "id": 7,
          "title": "Style Toast Notifications",
          "description": "Create comprehensive styles for toast notifications with animations",
          "dependencies": [
            1,
            2
          ],
          "details": "Develop CSS/SCSS styles for toast notifications with proper animations for entry and exit. Support different positions (top-right, bottom-left, etc.). Ensure responsive design and accessibility compliance including proper contrast and keyboard navigation.",
          "status": "done"
        }
      ]
    },
    {
      "id": 9,
      "title": "Handling Expired Tokens and Network Issues",
      "description": "Implement token refresh logic and handle network disconnections gracefully to ensure uninterrupted user experience.",
      "details": "1. Enhance the API service with token refresh and network handling (src/services/apiService.ts):\n```typescript\nimport { msalInstance } from '../auth/msalInstance';\nimport { loginRequest } from '../auth/msalConfig';\nimport { InteractionRequiredAuthError } from '@azure/msal-browser';\n\ninterface ApiOptions {\n  method?: string;\n  headers?: Record<string, string>;\n  body?: any;\n  retryCount?: number;\n}\n\nclass ApiService {\n  private baseUrl: string;\n  private maxRetries: number = 3;\n  private retryDelay: number = 1000; // 1 second\n  \n  constructor(baseUrl: string) {\n    this.baseUrl = baseUrl;\n  }\n  \n  private async getAuthToken(): Promise<string> {\n    try {\n      const account = msalInstance.getAllAccounts()[0];\n      if (!account) {\n        throw new Error('No active account! Signin required.');\n      }\n      \n      const response = await msalInstance.acquireTokenSilent({\n        ...loginRequest,\n        account\n      });\n      \n      return response.accessToken;\n    } catch (error) {\n      // If silent token acquisition fails due to interaction required\n      if (error instanceof InteractionRequiredAuthError) {\n        try {\n          const response = await msalInstance.acquireTokenPopup(loginRequest);\n          return response.accessToken;\n        } catch (interactiveError) {\n          throw interactiveError;\n        }\n      }\n      throw error;\n    }\n  }\n  \n  private async fetchWithAuth(url: string, options: ApiOptions = {}): Promise<Response> {\n    const retryCount = options.retryCount || 0;\n    \n    try {\n      const token = await this.getAuthToken();\n      \n      const headers = {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${token}`,\n        ...options.headers\n      };\n      \n      const config: RequestInit = {\n        method: options.method || 'GET',\n        headers,\n        body: options.body ? JSON.stringify(options.body) : undefined\n      };\n      \n      const response = await fetch(`${this.baseUrl}${url}`, config);\n      \n      if (!response.ok) {\n        // Handle different error status codes\n        if (response.status === 401) {\n          // Token might be expired, try to refresh and retry\n          if (retryCount < this.maxRetries) {\n            // Clear token cache to force new token acquisition\n            await msalInstance.clearCache();\n            \n            // Retry with incremented retry count\n            return this.fetchWithAuth(url, {\n              ...options,\n              retryCount: retryCount + 1\n            });\n          }\n        }\n        \n        const errorData = await response.json().catch(() => ({}));\n        throw new Error(errorData.message || `API error: ${response.status}`);\n      }\n      \n      return response;\n    } catch (error) {\n      // Handle network errors with retry logic\n      if (error instanceof TypeError && error.message.includes('network') && retryCount < this.maxRetries) {\n        // Exponential backoff for retries\n        const delay = this.retryDelay * Math.pow(2, retryCount);\n        \n        console.log(`Network error, retrying in ${delay}ms...`);\n        \n        return new Promise(resolve => {\n          setTimeout(() => {\n            resolve(this.fetchWithAuth(url, {\n              ...options,\n              retryCount: retryCount + 1\n            }));\n          }, delay);\n        });\n      }\n      \n      console.error('API request failed:', error);\n      throw error;\n    }\n  }\n  \n  // Rest of the API service methods (get, post, put, delete) remain the same\n}\n```\n\n2. Create a network status monitor (src/utils/networkMonitor.ts):\n```typescript\nimport { useState, useEffect } from 'react';\n\nexport function useNetworkStatus() {\n  const [isOnline, setIsOnline] = useState(navigator.onLine);\n  \n  useEffect(() => {\n    const handleOnline = () => setIsOnline(true);\n    const handleOffline = () => setIsOnline(false);\n    \n    window.addEventListener('online', handleOnline);\n    window.addEventListener('offline', handleOffline);\n    \n    return () => {\n      window.removeEventListener('online', handleOnline);\n      window.removeEventListener('offline', handleOffline);\n    };\n  }, []);\n  \n  return isOnline;\n}\n```\n\n3. Create a network status indicator component (src/components/NetworkStatus.tsx):\n```typescript\nimport React, { useEffect } from 'react';\nimport { useNetworkStatus } from '../utils/networkMonitor';\nimport { useToast } from './ToastContainer';\nimport '../styles/network-status.css';\n\nconst NetworkStatus: React.FC = () => {\n  const isOnline = useNetworkStatus();\n  const { showToast } = useToast();\n  \n  useEffect(() => {\n    if (isOnline) {\n      showToast('Your connection has been restored.', 'success');\n    } else {\n      showToast('You are currently offline. Some features may be unavailable.', 'warning', 0); // 0 means don't auto-dismiss\n    }\n  }, [isOnline, showToast]);\n  \n  if (isOnline) return null;\n  \n  return (\n    <div className=\"offline-indicator\">\n      <span>You are offline</span>\n    </div>\n  );\n};\n\nexport default NetworkStatus;\n```\n\n4. Create styles for the network status indicator (src/styles/network-status.css):\n```css\n.offline-indicator {\n  position: fixed;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  background-color: #d83b01;\n  color: white;\n  text-align: center;\n  padding: 0.5rem;\n  font-weight: bold;\n  z-index: 1000;\n}\n```\n\n5. Add the NetworkStatus component to the App:\n```typescript\nimport NetworkStatus from './components/NetworkStatus';\n\nfunction App() {\n  return (\n    <>\n      {/* Rest of your application */}\n      <NetworkStatus />\n    </>\n  );\n}\n```\n\n6. Enhance the AuthContext to handle token refresh (src/auth/AuthContext.tsx):\n```typescript\nimport { useEffect, useCallback } from 'react';\nimport { InteractionRequiredAuthError } from '@azure/msal-browser';\n\nexport const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {\n  // ... existing code\n  \n  // Function to refresh the token\n  const refreshToken = useCallback(async () => {\n    if (!account) return null;\n    \n    try {\n      const response = await instance.acquireTokenSilent({\n        ...loginRequest,\n        account\n      });\n      return response;\n    } catch (error) {\n      if (error instanceof InteractionRequiredAuthError) {\n        // Token expired and requires user interaction\n        try {\n          const response = await instance.acquireTokenPopup(loginRequest);\n          return response;\n        } catch (interactiveError) {\n          setError(interactiveError as Error);\n          return null;\n        }\n      }\n      setError(error as Error);\n      return null;\n    }\n  }, [account, instance]);\n  \n  // Set up a token refresh interval\n  useEffect(() => {\n    if (!account) return;\n    \n    // Refresh token every 45 minutes (Azure AD tokens typically last 1 hour)\n    const tokenRefreshInterval = setInterval(() => {\n      refreshToken();\n    }, 45 * 60 * 1000);\n    \n    return () => clearInterval(tokenRefreshInterval);\n  }, [account, refreshToken]);\n  \n  // ... rest of the component\n};\n```",
      "testStrategy": "1. Test token refresh logic by simulating expired tokens\n2. Verify that the API service correctly retries requests after token refresh\n3. Test network error handling with simulated network failures\n4. Verify that the network status indicator appears when offline\n5. Test the exponential backoff retry mechanism\n6. Verify that authentication state is maintained during network disconnections\n7. Test the automatic token refresh interval\n8. Verify that appropriate notifications are shown when network status changes",
      "priority": "medium",
      "dependencies": [
        3
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 10,
      "title": "Silent Authentication Implementation",
      "description": "Implement silent authentication for returning users to provide a seamless experience without requiring explicit login.",
      "details": "1. Create a silent authentication handler (src/auth/SilentAuth.tsx):\n```typescript\nimport React, { useEffect, useState } from 'react';\nimport { useMsal } from '@azure/msal-react';\nimport { loginRequest } from './msalConfig';\nimport LoadingSpinner from '../components/LoadingSpinner';\n\ninterface SilentAuthProps {\n  children: React.ReactNode;\n}\n\nconst SilentAuth: React.FC<SilentAuthProps> = ({ children }) => {\n  const { instance, accounts } = useMsal();\n  const [isAttemptingLogin, setIsAttemptingLogin] = useState(true);\n  \n  useEffect(() => {\n    const attemptSilentLogin = async () => {\n      // Only attempt silent login if there's an account\n      if (accounts.length > 0) {\n        try {\n          await instance.acquireTokenSilent({\n            ...loginRequest,\n            account: accounts[0]\n          });\n        } catch (error) {\n          console.log('Silent token acquisition failed', error);\n          // We don't need to do anything here, as the user will be prompted to login\n          // when they try to access a protected resource\n        }\n      }\n      \n      setIsAttemptingLogin(false);\n    };\n    \n    attemptSilentLogin();\n  }, [instance, accounts]);\n  \n  if (isAttemptingLogin) {\n    return <LoadingSpinner message=\"Checking authentication status...\" />;\n  }\n  \n  return <>{children}</>;\n};\n\nexport default SilentAuth;\n```\n\n2. Update the App component to use SilentAuth (src/App.tsx):\n```typescript\nimport SilentAuth from './auth/SilentAuth';\n\nfunction App() {\n  return (\n    <SilentAuth>\n      {/* Rest of your application */}\n    </SilentAuth>\n  );\n}\n```\n\n3. Create a hook to check if a user is returning (src/hooks/useReturningUser.ts):\n```typescript\nimport { useState, useEffect } from 'react';\n\nexport function useReturningUser() {\n  const [isReturningUser, setIsReturningUser] = useState(false);\n  \n  useEffect(() => {\n    // Check if user has visited before\n    const hasVisitedBefore = localStorage.getItem('hasVisitedBefore');\n    \n    if (hasVisitedBefore) {\n      setIsReturningUser(true);\n    } else {\n      // Set flag for future visits\n      localStorage.setItem('hasVisitedBefore', 'true');\n    }\n  }, []);\n  \n  return isReturningUser;\n}\n```\n\n4. Enhance the Login page to show different messages for returning users (src/pages/Login.tsx):\n```typescript\nimport { useReturningUser } from '../hooks/useReturningUser';\n\nconst Login: React.FC = () => {\n  // ... existing code\n  \n  const isReturningUser = useReturningUser();\n  \n  // ... rest of the component\n  \n  return (\n    <div className=\"login-container\">\n      <div className=\"login-card\">\n        <img src=\"/logo.png\" alt=\"FourSPM Logo\" className=\"login-logo\" />\n        \n        {isReturningUser ? (\n          <>\n            <h1>Welcome Back!</h1>\n            <p>We're attempting to sign you in automatically...</p>\n          </>\n        ) : (\n          <>\n            <h1>Welcome to FourSPM</h1>\n            <p>Please sign in with your Microsoft account to continue.</p>\n          </>\n        )}\n        \n        {/* Rest of the login form */}\n      </div>\n    </div>\n  );\n};\n```\n\n5. Create a session persistence utility (src/utils/sessionPersistence.ts):\n```typescript\n// Constants for storage keys\nconst STORAGE_PREFIX = 'fourspm_';\nconst AUTH_STATE_KEY = `${STORAGE_PREFIX}auth_state`;\n\n// Save authentication state to localStorage\nexport const saveAuthState = (account: any) => {\n  if (!account) return;\n  \n  const authState = {\n    username: account.username,\n    name: account.name,\n    lastLogin: new Date().toISOString()\n  };\n  \n  try {\n    localStorage.setItem(AUTH_STATE_KEY, JSON.stringify(authState));\n  } catch (error) {\n    console.error('Failed to save auth state to localStorage', error);\n  }\n};\n\n// Get saved authentication state\nexport const getSavedAuthState = () => {\n  try {\n    const savedState = localStorage.getItem(AUTH_STATE_KEY);\n    return savedState ? JSON.parse(savedState) : null;\n  } catch (error) {\n    console.error('Failed to retrieve auth state from localStorage', error);\n    return null;\n  }\n};\n\n// Clear saved authentication state\nexport const clearAuthState = () => {\n  try {\n    localStorage.removeItem(AUTH_STATE_KEY);\n  } catch (error) {\n    console.error('Failed to clear auth state from localStorage', error);\n  }\n};\n```\n\n6. Update the AuthContext to use session persistence (src/auth/AuthContext.tsx):\n```typescript\nimport { saveAuthState, clearAuthState, getSavedAuthState } from '../utils/sessionPersistence';\n\nexport const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {\n  // ... existing code\n  \n  // Save account info when it changes\n  useEffect(() => {\n    if (account) {\n      saveAuthState(account);\n    }\n  }, [account]);\n  \n  // Clear saved state on logout\n  const logout = async () => {\n    try {\n      clearAuthState();\n      await instance.logoutPopup();\n      // ... rest of logout logic\n    } catch (err) {\n      // ... error handling\n    }\n  };\n  \n  // ... rest of the component\n};\n```",
      "testStrategy": "1. Test silent authentication for returning users\n2. Verify that the loading spinner is shown during silent authentication\n3. Test the behavior when silent authentication succeeds\n4. Test the behavior when silent authentication fails\n5. Verify that different messages are shown for new vs. returning users\n6. Test session persistence across browser refreshes\n7. Verify that authentication state is properly saved and retrieved from localStorage\n8. Test the complete flow from initial login to returning user experience",
      "priority": "medium",
      "dependencies": [
        2,
        5
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 11,
      "title": "Permission Changes Handling",
      "description": "Implement logic to detect and handle permission changes during a user's session without requiring re-login.",
      "details": "1. Create a permission change detector (src/auth/PermissionChangeDetector.tsx):\n```typescript\nimport React, { useEffect, useState, useCallback } from 'react';\nimport { useMsal } from '@azure/msal-react';\nimport { loginRequest } from './msalConfig';\nimport { useAuth } from './AuthContext';\nimport { useToast } from '../components/ToastContainer';\n\ninterface PermissionChangeDetectorProps {\n  children: React.ReactNode;\n  checkInterval?: number; // in milliseconds\n}\n\nconst PermissionChangeDetector: React.FC<PermissionChangeDetectorProps> = ({ \n  children, \n  checkInterval = 5 * 60 * 1000 // Default: check every 5 minutes\n}) => {\n  const { instance, accounts } = useMsal();\n  const { user, setUser } = useAuth();\n  const { showToast } = useToast();\n  const [lastRoles, setLastRoles] = useState<string[]>([]);\n  \n  // Function to check for permission changes\n  const checkPermissions = useCallback(async () => {\n    if (!user || accounts.length === 0) return;\n    \n    try {\n      // Get a fresh token to get the latest claims\n      const response = await instance.acquireTokenSilent({\n        ...loginRequest,\n        account: accounts[0],\n        forceRefresh: true // Force a fresh token from AAD\n      });\n      \n      // Extract roles from token claims\n      const idTokenClaims = response.idTokenClaims as any;\n      const currentRoles = idTokenClaims.roles || [];\n      \n      // Compare with previous roles\n      if (lastRoles.length > 0 && JSON.stringify(lastRoles) !== JSON.stringify(currentRoles)) {\n        // Roles have changed\n        const addedRoles = currentRoles.filter((role: string) => !lastRoles.includes(role));\n        const removedRoles = lastRoles.filter(role => !currentRoles.includes(role));\n        \n        // Update user in context\n        setUser({\n          ...user,\n          roles: currentRoles\n        });\n        \n        // Notify user about changes\n        if (addedRoles.length > 0 || removedRoles.length > 0) {\n          let message = 'Your permissions have been updated.';\n          \n          if (addedRoles.length > 0) {\n            message += ` Added: ${addedRoles.join(', ')}.`;\n          }\n          \n          if (removedRoles.length > 0) {\n            message += ` Removed: ${removedRoles.join(', ')}.`;\n          }\n          \n          showToast(message, 'info');\n        }\n      }\n      \n      // Update last roles\n      setLastRoles(currentRoles);\n    } catch (error) {\n      console.error('Error checking for permission changes:', error);\n    }\n  }, [instance, accounts, user, lastRoles, setUser, showToast]);\n  \n  // Initialize lastRoles when user is first loaded\n  useEffect(() => {\n    if (user && user.roles && lastRoles.length === 0) {\n      setLastRoles(user.roles);\n    }\n  }, [user, lastRoles]);\n  \n  // Set up interval to check for permission changes\n  useEffect(() => {\n    if (!user) return;\n    \n    const intervalId = setInterval(checkPermissions, checkInterval);\n    \n    return () => clearInterval(intervalId);\n  }, [user, checkPermissions, checkInterval]);\n  \n  return <>{children}</>;\n};\n\nexport default PermissionChangeDetector;\n```\n\n2. Update the AuthContext to include setUser function (src/auth/AuthContext.tsx):\n```typescript\ninterface AuthContextType {\n  user: User | null;\n  setUser: React.Dispatch<React.SetStateAction<User | null>>;\n  isAuthenticated: boolean;\n  isLoading: boolean;\n  error: Error | null;\n  login: () => Promise<void>;\n  logout: () => Promise<void>;\n}\n\nexport const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {\n  // ... existing code\n  const [user, setUser] = useState<User | null>(null);\n  \n  // ... rest of the component\n  \n  const contextValue: AuthContextType = {\n    user,\n    setUser,\n    isAuthenticated: !!user,\n    isLoading: inProgress !== InteractionStatus.None,\n    error,\n    login,\n    logout\n  };\n  \n  return (\n    <AuthContext.Provider value={contextValue}>\n      {children}\n    </AuthContext.Provider>\n  );\n};\n```\n\n3. Add the PermissionChangeDetector to the App component (src/App.tsx):\n```typescript\nimport PermissionChangeDetector from './auth/PermissionChangeDetector';\n\nfunction App() {\n  return (\n    <AuthProvider>\n      <PermissionChangeDetector>\n        {/* Rest of your application */}\n      </PermissionChangeDetector>\n    </AuthProvider>\n  );\n}\n```\n\n4. Create a hook to check permissions (src/hooks/usePermission.ts):\n```typescript\nimport { useAuth } from '../auth/AuthContext';\n\nexport function usePermission(requiredPermission: string | string[]) {\n  const { user } = useAuth();\n  \n  if (!user || !user.roles) {\n    return false;\n  }\n  \n  const permissions = Array.isArray(requiredPermission) \n    ? requiredPermission \n    : [requiredPermission];\n  \n  return permissions.some(permission => user.roles.includes(permission));\n}\n```\n\n5. Create a conditional rendering component based on permissions (src/components/PermissionGate.tsx):\n```typescript\nimport React from 'react';\nimport { usePermission } from '../hooks/usePermission';\n\ninterface PermissionGateProps {\n  permissions: string | string[];\n  children: React.ReactNode;\n  fallback?: React.ReactNode;\n}\n\nconst PermissionGate: React.FC<PermissionGateProps> = ({ \n  permissions, \n  children, \n  fallback = null \n}) => {\n  const hasPermission = usePermission(permissions);\n  \n  return hasPermission ? <>{children}</> : <>{fallback}</>;\n};\n\nexport default PermissionGate;\n```\n\n6. Use the PermissionGate component for conditional rendering (example):\n```typescript\nimport PermissionGate from '../components/PermissionGate';\n\nconst Dashboard: React.FC = () => {\n  return (\n    <div>\n      <h1>Dashboard</h1>\n      \n      {/* This section only shows for users with the 'Admin' role */}\n      <PermissionGate permissions=\"Administrator\">\n        <div className=\"admin-section\">\n          <h2>Administration</h2>\n          <p>This content is only visible to administrators.</p>\n        </div>\n      </PermissionGate>\n      \n      {/* This section shows for users with either 'Editor' or 'Contributor' roles */}\n      <PermissionGate permissions={['Editor', 'Contributor']}>\n        <div className=\"content-section\">\n          <h2>Content Management</h2>\n          <p>This content is only visible to editors and contributors.</p>\n        </div>\n      </PermissionGate>\n    </div>\n  );\n};\n```",
      "testStrategy": "1. Create unit tests for the PermissionChangeDetector component\n2. Test the detection of added and removed roles\n3. Verify that the user context is updated when roles change\n4. Test that appropriate notifications are shown when permissions change\n5. Verify that the usePermission hook correctly checks for permissions\n6. Test the PermissionGate component with various permission scenarios\n7. Verify that UI elements are correctly shown/hidden based on permission changes\n8. Test the complete flow of permission changes during a user session",
      "priority": "low",
      "dependencies": [
        2,
        3,
        9
      ],
      "status": "deferred",
      "subtasks": []
    },
    {
      "id": 12,
      "title": "End-to-End Testing and Documentation",
      "description": "Create comprehensive end-to-end tests for the authentication flow and document the MSAL integration for future reference.",
      "details": "1. Create end-to-end tests using Cypress (cypress/integration/auth.spec.js):\n```javascript\ndescribe('Authentication Flow', () => {\n  beforeEach(() => {\n    // Visit the application\n    cy.visit('/');\n  });\n  \n  it('should redirect to login page when not authenticated', () => {\n    // Check that we're on the login page\n    cy.url().should('include', '/login');\n    cy.contains('Sign in with Microsoft').should('be.visible');\n  });\n  \n  it('should show login button', () => {\n    cy.get('.ms-login-button').should('be.visible');\n    cy.get('.ms-login-button').should('contain', 'Sign in with Microsoft');\n  });\n  \n  // Note: Testing actual Microsoft authentication requires special setup\n  // This is a mock test that simulates successful authentication\n  it('should handle successful authentication', () => {\n    // Mock MSAL authentication\n    cy.window().then(win => {\n      // Create a mock authenticated user\n      win.mockAuthenticatedUser = {\n        account: {\n          homeAccountId: 'test-account-id',\n          username: 'test@example.com',\n          name: 'Test User'\n        },\n        idTokenClaims: {\n          roles: ['User']\n        },\n        accessToken: 'mock-access-token'\n      };\n      \n      // Override MSAL loginPopup method\n      if (win.msal && win.msal.instance) {\n        cy.stub(win.msal.instance, 'loginPopup').resolves(win.mockAuthenticatedUser);\n        cy.stub(win.msal.instance, 'acquireTokenSilent').resolves(win.mockAuthenticatedUser);\n      }\n    });\n    \n    // Click login button\n    cy.get('.ms-login-button').click();\n    \n    // Should redirect to dashboard after login\n    cy.url().should('not.include', '/login');\n    \n    // User info should be displayed\n    cy.contains('Test User').should('be.visible');\n  });\n});\n```\n\n2. Create end-to-end tests for role management (cypress/integration/roles.spec.js):\n```javascript\ndescribe('Role Management', () => {\n  beforeEach(() => {\n    // Mock authentication as admin\n    cy.mockAdminAuth();\n    \n    // Visit the roles page\n    cy.visit('/roles');\n  });\n  \n  it('should display the roles grid', () => {\n    cy.get('.role-management-container').should('be.visible');\n    cy.contains('Role Management').should('be.visible');\n    cy.get('.dx-datagrid').should('be.visible');\n  });\n  \n  it('should allow adding a new role', () => {\n    // Click add button\n    cy.get('.dx-datagrid-addrow-button').click();\n    \n    // Fill in role details\n    cy.get('[aria-label=\"Name\"]').type('Test Role');\n    cy.get('[aria-label=\"Description\"]').type('Role created during automated testing');\n    \n    // Save the role\n    cy.get('.dx-popup-done').click();\n    \n    // Verify role was added\n    cy.contains('Test Role').should('be.visible');\n  });\n  \n  it('should navigate to permission management', () => {\n    // Find the first role and click its permissions button\n    cy.get('.dx-datagrid-content')\n      .find('tr')\n      .first()\n      .find('[aria-label=\"Manage Permissions\"]')\n      .click();\n    \n    // Verify we're on the permissions page\n    cy.url().should('include', '/permissions');\n    cy.contains('Manage Permissions for').should('be.visible');\n  });\n});\n```\n\n3. Create custom Cypress commands for authentication (cypress/support/commands.js):\n```javascript\n// Mock authentication as a regular user\nCypress.Commands.add('mockUserAuth', () => {\n  cy.window().then(win => {\n    win.mockAuthenticatedUser = {\n      account: {\n        homeAccountId: 'user-account-id',\n        username: 'user@example.com',\n        name: 'Regular User'\n      },\n      idTokenClaims: {\n        roles: ['User']\n      },\n      accessToken: 'mock-user-access-token'\n    };\n    \n    if (win.msal && win.msal.instance) {\n      cy.stub(win.msal.instance, 'getAllAccounts').returns([win.mockAuthenticatedUser.account]);\n      cy.stub(win.msal.instance, 'acquireTokenSilent').resolves(win.mockAuthenticatedUser);\n    }\n  });\n});\n\n// Mock authentication as an admin user\nCypress.Commands.add('mockAdminAuth', () => {\n  cy.window().then(win => {\n    win.mockAuthenticatedUser = {\n      account: {\n        homeAccountId: 'admin-account-id',\n        username: 'admin@example.com',\n        name: 'Admin User'\n      },\n      idTokenClaims: {\n        roles: ['User', 'Administrator']\n      },\n      accessToken: 'mock-admin-access-token'\n    };\n    \n    if (win.msal && win.msal.instance) {\n      cy.stub(win.msal.instance, 'getAllAccounts').returns([win.mockAuthenticatedUser.account]);\n      cy.stub(win.msal.instance, 'acquireTokenSilent').resolves(win.mockAuthenticatedUser);\n    }\n  });\n});\n```\n\n4. Create documentation for the MSAL integration (docs/MSAL-Integration.md):\n```markdown\n# MSAL Integration Documentation\n\n## Overview\n\nThis document provides technical details about the Microsoft Authentication Library (MSAL) integration in the FourSPM application. The integration enables Single Sign-On (SSO) capabilities through Azure Active Directory (Azure AD).\n\n## Configuration\n\n### Azure AD Configuration\n\n- **Application (client) ID**: c67bf91d-8b6a-494a-8b99-c7a4592e08c1\n- **Directory (tenant) ID**: 3c7fa9e9-64e7-443c-905a-d9134ca00da9\n- **Redirect URI**: The application's origin (e.g., https://app.fourspm.com)\n\n### Environment Variables\n\nThe application uses the following environment variables for configuration:\n\n- `REACT_APP_ENVIRONMENT`: The current environment (development or production)\n- `REACT_APP_AZURE_CLIENT_ID`: The Azure AD application client ID\n- `REACT_APP_AZURE_TENANT_ID`: The Azure AD tenant ID\n- `REACT_APP_API_BASE_URL`: The base URL for API requests\n\n## Authentication Flow\n\n1. **Initial Load**: When the application loads, it attempts silent authentication for returning users.\n2. **Login**: Users click the \"Sign in with Microsoft\" button, which opens a popup for Microsoft authentication.\n3. **Token Acquisition**: After successful authentication, MSAL acquires access and ID tokens.\n4. **User Information**: User details and roles are extracted from the ID token claims.\n5. **Token Refresh**: Tokens are automatically refreshed when they expire.\n\n## Components\n\n### AuthProvider\n\nThe `AuthProvider` component manages the authentication state and provides authentication-related functions to the application.\n\n```jsx\n<AuthProvider>\n  {/* Application components */}\n</AuthProvider>\n```\n\n### RequireAuth\n\nThe `RequireAuth` component protects routes based on authentication status and user roles.\n\n```jsx\n<RequireAuth requiredRoles={['Administrator']}>\n  <ProtectedComponent />\n</RequireAuth>\n```\n\n### PermissionGate\n\nThe `PermissionGate` component conditionally renders content based on user permissions.\n\n```jsx\n<PermissionGate permissions=\"Administrator\">\n  <AdminContent />\n</PermissionGate>\n```\n\n## API Integration\n\nThe `apiService` automatically includes authentication tokens in API requests and handles token refresh when needed.\n\n```javascript\n// Example API call\nconst data = await apiService.get('/api/endpoint');\n```\n\n## Error Handling\n\nThe application includes comprehensive error handling for authentication failures:\n\n- Network disconnections\n- Expired tokens\n- Authentication rejections\n- Permission changes\n\n## Role Management\n\nThe application includes interfaces for managing roles and permissions:\n\n- `/roles`: Grid for viewing, adding, editing, and deleting roles\n- `/roles/:roleId/permissions`: Interface for assigning permissions to roles\n\n## Troubleshooting\n\n### Common Issues\n\n1. **Authentication Popup Blocked**: Ensure popup blockers are disabled for the application.\n2. **Token Expiration**: If tokens expire unexpectedly, check the Azure AD token lifetime policy.\n3. **Missing Permissions**: Verify that the user has the required roles assigned in Azure AD.\n\n### Debugging\n\nSet `REACT_APP_ENVIRONMENT` to `development` to enable verbose logging of MSAL activities.\n```\n\n5. Create a README file for the authentication module (src/auth/README.md):\n```markdown\n# Authentication Module\n\n## Overview\n\nThis module handles authentication using Microsoft Authentication Library (MSAL) for the FourSPM application.\n\n## Components\n\n- `AuthContext.tsx`: Provides authentication state and functions\n- `RequireAuth.tsx`: Protects routes based on authentication and roles\n- `SilentAuth.tsx`: Handles silent authentication for returning users\n- `PermissionChangeDetector.tsx`: Detects changes in user permissions\n- `msalConfig.ts`: Configuration for MSAL\n- `msalInstance.ts`: Exports the MSAL instance\n\n## Usage\n\n### Protecting Routes\n\n```jsx\n<Route path=\"/protected\" element={\n  <RequireAuth>\n    <ProtectedComponent />\n  </RequireAuth>\n} />\n```\n\n### Role-Based Protection\n\n```jsx\n<Route path=\"/admin\" element={\n  <RequireAuth requiredRoles={['Administrator']}>\n    <AdminComponent />\n  </RequireAuth>\n} />\n```\n\n### Using Authentication Context\n\n```jsx\nimport { useAuth } from './auth/AuthContext';\n\nfunction MyComponent() {\n  const { user, isAuthenticated, login, logout } = useAuth();\n  \n  return (\n    <div>\n      {isAuthenticated ? (\n        <>\n          <p>Welcome, {user.displayName}</p>\n          <button onClick={logout}>Logout</button>\n        </>\n      ) : (\n        <button onClick={login}>Login</button>\n      )}\n    </div>\n  );\n}\n```\n\n### Conditional Rendering Based on Permissions\n\n```jsx\nimport PermissionGate from './components/PermissionGate';\n\nfunction MyComponent() {\n  return (\n    <div>\n      <PermissionGate permissions=\"Administrator\">\n        <AdminSection />\n      </PermissionGate>\n    </div>\n  );\n}\n```\n\n## Configuration\n\nUpdate the MSAL configuration in `msalConfig.ts` if needed. The configuration uses environment variables for client ID and tenant ID.\n```",
      "testStrategy": "1. Set up Cypress for end-to-end testing\n2. Create tests for the complete authentication flow\n3. Test role-based access control\n4. Verify that protected routes are properly secured\n5. Test the role and permission management interfaces\n6. Create tests for error scenarios and edge cases\n7. Document all test scenarios and expected outcomes\n8. Create comprehensive documentation for the MSAL integration\n9. Verify that all documentation is accurate and up-to-date\n10. Create a README file for the authentication module",
      "priority": "low",
      "dependencies": [
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11
      ],
      "status": "done",
      "subtasks": []
    }
  ]
}