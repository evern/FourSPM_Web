{
  "tasks": [
    {
      "id": 1,
      "title": "Install and configure MSAL dependencies",
      "description": "Add Microsoft Authentication Library dependencies to the project and set up the initial configuration structure.",
      "details": "1. Install required packages:\n```bash\nnpm install @azure/msal-browser@^2.32.0 @azure/msal-react@^1.5.0\n```\n2. Create a configuration file (src/auth/msalConfig.ts) with the following structure:\n```typescript\nimport { Configuration, LogLevel } from '@azure/msal-browser';\n\nexport const msalConfig: Configuration = {\n  auth: {\n    clientId: 'c67bf91d-8b6a-494a-8b99-c7a4592e08c1',\n    authority: 'https://login.microsoftonline.com/3c7fa9ef-64e7-443c-905a-d9134ca004a9',\n    redirectUri: window.location.origin,\n  },\n  cache: {\n    cacheLocation: 'localStorage',\n    storeAuthStateInCookie: false,\n  },\n  system: {\n    loggerOptions: {\n      loggerCallback: (level, message, containsPii) => {\n        if (containsPii) return;\n        switch (level) {\n          case LogLevel.Error:\n            console.error(message);\n            break;\n          case LogLevel.Info:\n            console.info(message);\n            break;\n          case LogLevel.Verbose:\n            console.debug(message);\n            break;\n          case LogLevel.Warning:\n            console.warn(message);\n            break;\n        }\n      },\n      logLevel: LogLevel.Info,\n    },\n  },\n};\n\nexport const loginRequest = {\n  scopes: [\n    'api://c67bf91d-8b6a-494a-8b99-c7a4592e08c1/Application.Admin',\n    'api://c67bf91d-8b6a-494a-8b99-c7a4592e08c1/Application.User'\n  ],\n};\n```",
      "testStrategy": "1. Verify that all dependencies are correctly installed by checking package.json\n2. Validate the configuration file structure and values against the PRD requirements\n3. Ensure the clientId, tenantId, and scopes match the values specified in the PRD\n4. Confirm that the configuration can be imported without errors",
      "priority": "high",
      "dependencies": [],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 2,
      "title": "Create MSAL Authentication Context",
      "description": "Implement the MSALAuthContext to manage authentication state and provide methods for login, logout, and token acquisition.",
      "details": "Create a new authentication context (src/auth/MSALAuthContext.tsx) that will handle MSAL authentication:\n\n```typescript\nimport { createContext, useContext, useState, useEffect, ReactNode } from 'react';\nimport { PublicClientApplication, AuthenticationResult, AccountInfo, InteractionRequiredAuthError, InteractionStatus } from '@azure/msal-browser';\nimport { msalConfig, loginRequest } from './msalConfig';\n\ninterface User {\n  id: string;\n  name: string;\n  email: string;\n  roles: string[];\n  accessToken: string;\n}\n\ninterface MSALAuthContextType {\n  isAuthenticated: boolean;\n  isLoading: boolean;\n  user: User | null;\n  error: string | null;\n  login: () => Promise<void>;\n  logout: () => Promise<void>;\n  acquireToken: () => Promise<string | null>;\n}\n\nconst MSALAuthContext = createContext<MSALAuthContextType | undefined>(undefined);\n\nconst msalInstance = new PublicClientApplication(msalConfig);\n\nexport const MSALAuthProvider = ({ children }: { children: ReactNode }) => {\n  const [isAuthenticated, setIsAuthenticated] = useState<boolean>(false);\n  const [isLoading, setIsLoading] = useState<boolean>(true);\n  const [user, setUser] = useState<User | null>(null);\n  const [error, setError] = useState<string | null>(null);\n\n  useEffect(() => {\n    const initializeAuth = async () => {\n      try {\n        // Handle redirect promise\n        await msalInstance.handleRedirectPromise();\n        \n        // Check if user is already signed in\n        const accounts = msalInstance.getAllAccounts();\n        if (accounts.length > 0) {\n          msalInstance.setActiveAccount(accounts[0]);\n          await handleSignedInAccount(accounts[0]);\n        }\n      } catch (err) {\n        console.error('MSAL Initialization Error', err);\n        setError('Failed to initialize authentication');\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    initializeAuth();\n  }, []);\n\n  const handleSignedInAccount = async (account: AccountInfo) => {\n    try {\n      const tokenResponse = await msalInstance.acquireTokenSilent({\n        ...loginRequest,\n        account\n      });\n      \n      const user = mapAccountToUser(account, tokenResponse);\n      setUser(user);\n      setIsAuthenticated(true);\n      setError(null);\n    } catch (err) {\n      if (err instanceof InteractionRequiredAuthError) {\n        // Silent token acquisition failed, user interaction required\n        setIsAuthenticated(false);\n        setUser(null);\n      } else {\n        console.error('Token acquisition error', err);\n        setError('Failed to acquire authentication token');\n      }\n    }\n  };\n\n  const mapAccountToUser = (account: AccountInfo, tokenResponse: AuthenticationResult): User => {\n    // Extract roles from ID token claims\n    const idTokenClaims = tokenResponse.idTokenClaims as any;\n    const roles = idTokenClaims?.roles || [];\n    \n    return {\n      id: account.homeAccountId,\n      name: account.name || '',\n      email: account.username,\n      roles,\n      accessToken: tokenResponse.accessToken\n    };\n  };\n\n  const login = async (): Promise<void> => {\n    setIsLoading(true);\n    setError(null);\n    \n    try {\n      // Attempt login with popup as primary method\n      const response = await msalInstance.loginPopup(loginRequest);\n      await handleSignedInAccount(response.account);\n    } catch (err: any) {\n      console.error('Login error', err);\n      if (err.name === 'PopupBlockedError') {\n        // Fallback to redirect if popup is blocked\n        msalInstance.loginRedirect(loginRequest);\n      } else {\n        setError(err.message || 'Failed to sign in');\n      }\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const logout = async (): Promise<void> => {\n    try {\n      await msalInstance.logoutPopup();\n      setIsAuthenticated(false);\n      setUser(null);\n    } catch (err) {\n      console.error('Logout error', err);\n      // Even if logout fails, clear local state\n      setIsAuthenticated(false);\n      setUser(null);\n    }\n  };\n\n  const acquireToken = async (): Promise<string | null> => {\n    try {\n      const account = msalInstance.getActiveAccount();\n      if (!account) {\n        throw new Error('No active account');\n      }\n      \n      const response = await msalInstance.acquireTokenSilent({\n        ...loginRequest,\n        account\n      });\n      \n      // Update user with new token\n      setUser(prev => prev ? { ...prev, accessToken: response.accessToken } : null);\n      return response.accessToken;\n    } catch (err) {\n      if (err instanceof InteractionRequiredAuthError) {\n        try {\n          // Silent token acquisition failed, try interactive method\n          const response = await msalInstance.acquireTokenPopup(loginRequest);\n          setUser(prev => prev ? { ...prev, accessToken: response.accessToken } : null);\n          return response.accessToken;\n        } catch (interactiveErr) {\n          console.error('Interactive token acquisition failed', interactiveErr);\n          setError('Authentication session expired. Please sign in again.');\n          setIsAuthenticated(false);\n          setUser(null);\n          return null;\n        }\n      } else {\n        console.error('Token acquisition error', err);\n        setError('Failed to acquire authentication token');\n        return null;\n      }\n    }\n  };\n\n  const contextValue: MSALAuthContextType = {\n    isAuthenticated,\n    isLoading,\n    user,\n    error,\n    login,\n    logout,\n    acquireToken\n  };\n\n  return (\n    <MSALAuthContext.Provider value={contextValue}>\n      {children}\n    </MSALAuthContext.Provider>\n  );\n};\n\nexport const useMSALAuth = (): MSALAuthContextType => {\n  const context = useContext(MSALAuthContext);\n  if (context === undefined) {\n    throw new Error('useMSALAuth must be used within an MSALAuthProvider');\n  }\n  return context;\n};\n```",
      "testStrategy": "1. Create unit tests to verify the context initialization\n2. Test the login, logout, and acquireToken methods with mocked MSAL responses\n3. Verify that user state is correctly updated after authentication\n4. Test error handling for various authentication scenarios\n5. Verify that the context provides the expected interface",
      "priority": "high",
      "dependencies": [
        1
      ],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "Create Core Authentication Context Structure",
          "description": "Set up the basic MSAL Authentication Context structure with provider and hook patterns",
          "dependencies": [],
          "details": "1. Create an AuthContext.tsx file\n2. Define the AuthContextState interface with properties: account, inProgress, isAuthenticated, error\n3. Create the AuthContext using React.createContext\n4. Implement the AuthProvider component that will wrap the application\n5. Set up the MSAL instance configuration with proper authority and redirect URI\n6. Initialize the PublicClientApplication from @azure/msal-browser\n7. Create and export a useAuth hook for consuming components\n8. Add proper TypeScript types for all components and functions\n9. Test the context initialization without authentication logic",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Implement Authentication State Management",
          "description": "Add state management logic to track authentication status, user account, and error handling",
          "dependencies": [
            1
          ],
          "details": "1. Add useState hooks for tracking: account, inProgress, isAuthenticated, error\n2. Implement useEffect to check for existing accounts on component mount\n3. Create handleRedirectPromise function to handle redirect responses\n4. Add event callbacks for MSAL events (loginSuccess, loginFailure, etc.)\n5. Implement a function to determine if a user is authenticated\n6. Create error handling utilities for authentication errors\n7. Add state update functions that maintain immutability\n8. Implement proper cleanup in useEffect to prevent memory leaks\n9. Test state updates with mock authentication events",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Implement Login Functionality",
          "description": "Create login methods supporting both popup and redirect flows with proper error handling",
          "dependencies": [
            1,
            2
          ],
          "details": "1. Implement loginPopup function using MSAL's loginPopup method\n2. Implement loginRedirect function using MSAL's loginRedirect method\n3. Create a login configuration object with proper scopes\n4. Add error handling for failed login attempts\n5. Update authentication state after successful login\n6. Implement silent login functionality for session persistence\n7. Add login hint support for improved user experience\n8. Create test cases for successful login\n9. Create test cases for failed login scenarios\n10. Document the login API for consuming components",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Implement Logout Functionality",
          "description": "Create logout methods with proper state cleanup and server session termination",
          "dependencies": [
            1,
            2,
            3
          ],
          "details": "1. Implement logout function using MSAL's logout method\n2. Add support for both popup and redirect logout flows\n3. Create proper state cleanup after logout\n4. Implement postLogoutRedirectUri configuration\n5. Add confirmation dialog option before logout\n6. Handle edge cases like logout during in-progress operations\n7. Create test cases for successful logout\n8. Create test cases for failed logout scenarios\n9. Document the logout API for consuming components\n10. Ensure all cached tokens are properly cleared",
          "status": "pending"
        },
        {
          "id": 5,
          "title": "Implement Token Acquisition and Management",
          "description": "Add token acquisition, caching, and refresh functionality with proper error handling",
          "dependencies": [
            1,
            2,
            3
          ],
          "details": "1. Implement acquireToken function using MSAL's acquireTokenSilent\n2. Add fallback to interactive methods when silent acquisition fails\n3. Create token caching mechanism for performance\n4. Implement token refresh logic before expiration\n5. Add proper scopes management for different API endpoints\n6. Create utility to check if token is expired\n7. Implement token acquisition queue to prevent race conditions\n8. Add comprehensive error handling for token acquisition failures\n9. Create test cases for successful token acquisition\n10. Create test cases for token refresh scenarios\n11. Document the token API for consuming components",
          "status": "pending"
        }
      ]
    },
    {
      "id": 3,
      "title": "Implement MSAL React Provider Integration",
      "description": "Integrate the MSAL React provider with the application to enable MSAL authentication throughout the app.",
      "details": "Create a wrapper component that integrates the MSAL React provider with our custom auth context:\n\n```typescript\n// src/auth/MSALProvider.tsx\nimport { ReactNode } from 'react';\nimport { MsalProvider } from '@azure/msal-react';\nimport { PublicClientApplication } from '@azure/msal-browser';\nimport { msalConfig } from './msalConfig';\nimport { MSALAuthProvider } from './MSALAuthContext';\n\ninterface MSALProviderWrapperProps {\n  children: ReactNode;\n}\n\n// Initialize MSAL instance\nconst msalInstance = new PublicClientApplication(msalConfig);\n\nexport const MSALProviderWrapper = ({ children }: MSALProviderWrapperProps) => {\n  return (\n    <MsalProvider instance={msalInstance}>\n      <MSALAuthProvider>\n        {children}\n      </MSALAuthProvider>\n    </MsalProvider>\n  );\n};\n```\n\nUpdate the application's entry point to use the MSAL provider:\n\n```typescript\n// src/index.tsx or App.tsx\nimport React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport { BrowserRouter } from 'react-router-dom';\nimport App from './App';\nimport { MSALProviderWrapper } from './auth/MSALProvider';\n\nconst root = ReactDOM.createRoot(document.getElementById('root') as HTMLElement);\n\nroot.render(\n  <React.StrictMode>\n    <BrowserRouter>\n      <MSALProviderWrapper>\n        <App />\n      </MSALProviderWrapper>\n    </BrowserRouter>\n  </React.StrictMode>\n);\n```",
      "testStrategy": "1. Verify that the MSAL provider is correctly initialized\n2. Test that the provider wrapper renders without errors\n3. Check that child components can access the MSAL context\n4. Verify that the application can initialize with the MSAL provider in place\n5. Test integration with React Router for protected routes",
      "priority": "high",
      "dependencies": [
        1,
        2
      ],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "Create MSAL Provider Wrapper Component",
          "description": "Develop a wrapper component that integrates the MSAL React Provider with the custom authentication context",
          "dependencies": [],
          "details": "1. Create a new component file (e.g., MsalProviderWrapper.tsx)\n2. Import necessary MSAL dependencies (MsalProvider, PublicClientApplication)\n3. Import the custom AuthContext/Provider\n4. Configure MSAL instance with appropriate authentication parameters (authority, clientId, redirectUri)\n5. Create the wrapper component that nests the AuthProvider inside the MsalProvider\n6. Implement proper prop passing between providers\n7. Add error handling for MSAL initialization failures\n8. Document the component with JSDoc comments",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Integrate MSAL Provider in Application Entry Point",
          "description": "Update the application's main entry point to use the MSAL Provider wrapper component",
          "dependencies": [
            1
          ],
          "details": "1. Modify the main application file (e.g., index.tsx or App.tsx)\n2. Import the MsalProviderWrapper component\n3. Replace the existing AuthProvider implementation with the new wrapper\n4. Ensure all existing props and children are properly passed through\n5. Update any imports or references that might be affected\n6. Verify that the application structure remains intact\n7. Add appropriate comments explaining the MSAL integration\n8. Check for any potential circular dependencies",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Test MSAL Integration and Authentication Flow",
          "description": "Verify that the MSAL integration works correctly by testing the authentication flow",
          "dependencies": [
            1,
            2
          ],
          "details": "1. Create test cases for login, logout, and token acquisition\n2. Test silent authentication flow for returning users\n3. Verify redirect handling after authentication\n4. Test error scenarios (e.g., expired tokens, network failures)\n5. Verify that protected routes require authentication\n6. Test token caching and refresh mechanisms\n7. Validate that user context is properly populated after authentication\n8. Create documentation for the authentication flow\n9. Verify browser compatibility (Chrome, Firefox, Safari, Edge)\n10. Test on different devices (desktop, mobile)",
          "status": "pending"
        }
      ]
    },
    {
      "id": 4,
      "title": "Create Microsoft Login Button Component",
      "description": "Develop a reusable Microsoft login button component that follows Microsoft's branding guidelines and handles the authentication flow.",
      "details": "Create a styled Microsoft login button component:\n\n```typescript\n// src/components/auth/MicrosoftLoginButton.tsx\nimport React from 'react';\nimport { useMSALAuth } from '../../auth/MSALAuthContext';\n\ninterface MicrosoftLoginButtonProps {\n  className?: string;\n  onLoginSuccess?: () => void;\n  onLoginError?: (error: string) => void;\n}\n\nconst MicrosoftLoginButton: React.FC<MicrosoftLoginButtonProps> = ({\n  className = '',\n  onLoginSuccess,\n  onLoginError\n}) => {\n  const { login, isLoading } = useMSALAuth();\n\n  const handleLogin = async () => {\n    try {\n      await login();\n      if (onLoginSuccess) onLoginSuccess();\n    } catch (error: any) {\n      if (onLoginError) onLoginError(error.message || 'Login failed');\n    }\n  };\n\n  return (\n    <button\n      type=\"button\"\n      className={`microsoft-login-button ${className}`}\n      onClick={handleLogin}\n      disabled={isLoading}\n      aria-label=\"Sign in with Microsoft\"\n    >\n      <span className=\"microsoft-icon\">\n        {/* Microsoft logo SVG */}\n        <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"21\" height=\"21\" viewBox=\"0 0 21 21\">\n          <rect x=\"1\" y=\"1\" width=\"9\" height=\"9\" fill=\"#f25022\" />\n          <rect x=\"1\" y=\"11\" width=\"9\" height=\"9\" fill=\"#00a4ef\" />\n          <rect x=\"11\" y=\"1\" width=\"9\" height=\"9\" fill=\"#7fba00\" />\n          <rect x=\"11\" y=\"11\" width=\"9\" height=\"9\" fill=\"#ffb900\" />\n        </svg>\n      </span>\n      <span className=\"button-text\">\n        {isLoading ? 'Signing in...' : 'Sign in with Microsoft'}\n      </span>\n    </button>\n  );\n};\n\nexport default MicrosoftLoginButton;\n```\n\nAdd the corresponding CSS:\n\n```css\n/* src/components/auth/MicrosoftLoginButton.css */\n.microsoft-login-button {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  padding: 10px 16px;\n  background-color: #ffffff;\n  color: #5e5e5e;\n  border: 1px solid #8c8c8c;\n  border-radius: 4px;\n  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n  font-size: 15px;\n  font-weight: 600;\n  cursor: pointer;\n  transition: background-color 0.2s ease;\n  min-width: 240px;\n  height: 41px;\n}\n\n.microsoft-login-button:hover {\n  background-color: #f3f3f3;\n}\n\n.microsoft-login-button:focus {\n  outline: none;\n  box-shadow: 0 0 0 2px rgba(0, 120, 212, 0.5);\n}\n\n.microsoft-login-button:disabled {\n  opacity: 0.7;\n  cursor: not-allowed;\n}\n\n.microsoft-icon {\n  margin-right: 12px;\n  display: flex;\n  align-items: center;\n}\n\n.button-text {\n  flex: 1;\n  text-align: center;\n}\n```",
      "testStrategy": "1. Verify that the button renders correctly with proper Microsoft branding\n2. Test the button's click handler to ensure it triggers the login function\n3. Verify loading state is displayed during authentication\n4. Test that success and error callbacks are invoked appropriately\n5. Verify accessibility features (keyboard navigation, ARIA attributes)\n6. Test the button's appearance across different screen sizes",
      "priority": "medium",
      "dependencies": [
        2,
        3
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 5,
      "title": "Create New Login Page with MSAL Authentication",
      "description": "Design and implement a new login page that incorporates the Microsoft login button and handles authentication flows.",
      "details": "Create a new login page component that uses the Microsoft login button:\n\n```typescript\n// src/pages/LoginPage.tsx\nimport React, { useState, useEffect } from 'react';\nimport { useNavigate, useLocation } from 'react-router-dom';\nimport { useMSALAuth } from '../auth/MSALAuthContext';\nimport MicrosoftLoginButton from '../components/auth/MicrosoftLoginButton';\nimport './LoginPage.css';\n\nconst LoginPage: React.FC = () => {\n  const { isAuthenticated, isLoading, error: authError } = useMSALAuth();\n  const [error, setError] = useState<string | null>(null);\n  const navigate = useNavigate();\n  const location = useLocation();\n  \n  // Get the return URL from location state or default to home\n  const from = (location.state as any)?.from?.pathname || '/';\n\n  useEffect(() => {\n    // If user is already authenticated, redirect to the intended destination\n    if (isAuthenticated && !isLoading) {\n      navigate(from, { replace: true });\n    }\n  }, [isAuthenticated, isLoading, navigate, from]);\n\n  useEffect(() => {\n    // Update local error state when auth context error changes\n    if (authError) {\n      setError(authError);\n    }\n  }, [authError]);\n\n  const handleLoginSuccess = () => {\n    setError(null);\n    // Navigation will be handled by the useEffect above\n  };\n\n  const handleLoginError = (errorMessage: string) => {\n    setError(errorMessage);\n  };\n\n  return (\n    <div className=\"login-page\">\n      <div className=\"login-container\">\n        <div className=\"login-header\">\n          <img src=\"/logo.png\" alt=\"FourSPM Logo\" className=\"logo\" />\n          <h1>Welcome to FourSPM</h1>\n        </div>\n        \n        <div className=\"login-form\">\n          {isLoading ? (\n            <div className=\"loading-indicator\">\n              <span className=\"spinner\"></span>\n              <p>Authenticating...</p>\n            </div>\n          ) : (\n            <>\n              <p className=\"login-instruction\">\n                Sign in with your Microsoft account to access FourSPM.\n              </p>\n              \n              <MicrosoftLoginButton \n                onLoginSuccess={handleLoginSuccess}\n                onLoginError={handleLoginError}\n                className=\"login-button\"\n              />\n              \n              {error && (\n                <div className=\"error-message\">\n                  <p>{error}</p>\n                  <p className=\"error-help\">\n                    If you continue to experience issues, please contact support.\n                  </p>\n                </div>\n              )}\n            </>\n          )}\n        </div>\n        \n        <div className=\"login-footer\">\n          <p>&copy; {new Date().getFullYear()} FourSPM. All rights reserved.</p>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default LoginPage;\n```\n\nAdd the corresponding CSS:\n\n```css\n/* src/pages/LoginPage.css */\n.login-page {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  min-height: 100vh;\n  background-color: #f5f5f5;\n}\n\n.login-container {\n  width: 100%;\n  max-width: 450px;\n  padding: 40px;\n  background-color: white;\n  border-radius: 8px;\n  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);\n}\n\n.login-header {\n  text-align: center;\n  margin-bottom: 30px;\n}\n\n.logo {\n  width: 120px;\n  margin-bottom: 20px;\n}\n\n.login-header h1 {\n  font-size: 24px;\n  color: #333;\n  margin: 0;\n}\n\n.login-form {\n  margin-bottom: 30px;\n}\n\n.login-instruction {\n  text-align: center;\n  margin-bottom: 20px;\n  color: #555;\n}\n\n.login-button {\n  width: 100%;\n  margin-bottom: 20px;\n}\n\n.error-message {\n  padding: 12px;\n  background-color: #fdeded;\n  border: 1px solid #f5c2c7;\n  border-radius: 4px;\n  color: #842029;\n  margin-top: 20px;\n}\n\n.error-help {\n  font-size: 14px;\n  margin-top: 8px;\n  margin-bottom: 0;\n}\n\n.loading-indicator {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n  padding: 20px;\n}\n\n.spinner {\n  border: 4px solid rgba(0, 0, 0, 0.1);\n  border-radius: 50%;\n  border-top: 4px solid #0078d4;\n  width: 30px;\n  height: 30px;\n  animation: spin 1s linear infinite;\n  margin-bottom: 15px;\n}\n\n@keyframes spin {\n  0% { transform: rotate(0deg); }\n  100% { transform: rotate(360deg); }\n}\n\n.login-footer {\n  text-align: center;\n  font-size: 14px;\n  color: #777;\n}\n\n/* Responsive adjustments */\n@media (max-width: 480px) {\n  .login-container {\n    padding: 30px 20px;\n    max-width: 100%;\n    margin: 0 15px;\n  }\n}\n```",
      "testStrategy": "1. Verify that the login page renders correctly with all UI elements\n2. Test that the Microsoft login button is displayed and functional\n3. Verify error messages are displayed when authentication fails\n4. Test loading states during authentication\n5. Verify redirection to the intended page after successful login\n6. Test responsive design on different screen sizes\n7. Verify accessibility compliance using automated tools",
      "priority": "high",
      "dependencies": [
        3,
        4
      ],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "Implement Login Page Layout and Design",
          "description": "Create the visual structure and styling for the login page following the application design system",
          "dependencies": [],
          "details": "1. Create a new React component for the login page\n2. Implement the form with username/email and password fields\n3. Add a submit button and 'forgot password' link\n4. Style the page according to design guidelines using CSS/SCSS\n5. Include the company logo and any welcome text\n6. Add form validation for input fields (required fields, email format)\n7. Ensure proper tab navigation between form elements\n\nAcceptance Criteria:\n- Page matches the approved design mockups\n- Form elements are properly aligned and styled\n- Visual feedback is provided for input focus states\n- Form layout maintains integrity at various screen sizes",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Implement Authentication Flow Integration",
          "description": "Connect the login form to the authentication service and handle user session management",
          "dependencies": [
            1
          ],
          "details": "1. Create form submission handler to capture user credentials\n2. Implement API service to communicate with authentication endpoints\n3. Add state management for login process (loading, success, failure states)\n4. Implement token storage in localStorage/sessionStorage\n5. Set up redirect to dashboard/home page after successful login\n6. Integrate with React Router for navigation\n7. Implement 'Remember me' functionality if required\n\nAcceptance Criteria:\n- Successful authentication redirects to the appropriate page\n- Authentication tokens are properly stored\n- User session persists through page refreshes if 'Remember me' is selected\n- Loading states are properly displayed during authentication\n- API calls are properly structured with error handling",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Implement Error Handling and User Feedback",
          "description": "Add comprehensive error handling for authentication failures and input validation with clear user feedback",
          "dependencies": [
            2
          ],
          "details": "1. Implement form validation error messages\n2. Create error handling for authentication failures (wrong credentials, account locked, etc.)\n3. Add visual indicators for validation errors (red borders, error icons)\n4. Implement toast/notification system for system-level errors\n5. Add accessibility attributes for error messages (aria-invalid, aria-describedby)\n6. Create retry logic for failed network requests\n7. Implement rate limiting protection for multiple failed attempts\n\nAcceptance Criteria:\n- All error states have clear, user-friendly messages\n- Form validation errors appear inline next to the relevant fields\n- Authentication errors are displayed prominently\n- Error messages are accessible to screen readers\n- Network errors are handled gracefully with retry options\n- Security measures prevent brute force attempts",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Implement Responsive Design and Cross-Browser Testing",
          "description": "Ensure the login page works correctly across all device sizes and major browsers",
          "dependencies": [
            1,
            3
          ],
          "details": "1. Implement responsive breakpoints for mobile, tablet, and desktop views\n2. Add media queries for different screen sizes\n3. Test and fix layout on iOS and Android devices\n4. Ensure functionality in Chrome, Firefox, Safari, and Edge browsers\n5. Optimize touch targets for mobile users\n6. Test and fix keyboard navigation for accessibility\n7. Implement automated tests for critical login functionality\n\nAcceptance Criteria:\n- Page renders correctly from 320px to 1920px width\n- All functionality works on touch devices\n- Form is usable on all major browsers (Chrome, Firefox, Safari, Edge)\n- Login process works with keyboard navigation only\n- Automated tests pass for core functionality\n- Page load time is optimized for mobile connections",
          "status": "pending"
        }
      ]
    },
    {
      "id": 6,
      "title": "Implement Protected Route Component",
      "description": "Create a protected route component that restricts access to authenticated users and handles redirection for unauthenticated users.",
      "details": "Create a protected route component that works with React Router v6:\n\n```typescript\n// src/components/auth/ProtectedRoute.tsx\nimport React from 'react';\nimport { Navigate, useLocation, Outlet } from 'react-router-dom';\nimport { useMSALAuth } from '../../auth/MSALAuthContext';\n\ninterface ProtectedRouteProps {\n  requiredRoles?: string[];\n}\n\nconst ProtectedRoute: React.FC<ProtectedRouteProps> = ({ requiredRoles = [] }) => {\n  const { isAuthenticated, isLoading, user } = useMSALAuth();\n  const location = useLocation();\n\n  // Show loading indicator while authentication state is being determined\n  if (isLoading) {\n    return (\n      <div className=\"auth-loading\">\n        <span className=\"spinner\"></span>\n        <p>Verifying authentication...</p>\n      </div>\n    );\n  }\n\n  // Check if user is authenticated\n  if (!isAuthenticated || !user) {\n    // Redirect to login page, but save the current location they were trying to access\n    return <Navigate to=\"/login\" state={{ from: location }} replace />;\n  }\n\n  // If specific roles are required, check if user has at least one of them\n  if (requiredRoles.length > 0) {\n    const hasRequiredRole = requiredRoles.some(role => user.roles.includes(role));\n    if (!hasRequiredRole) {\n      // User is authenticated but doesn't have the required role\n      return <Navigate to=\"/unauthorized\" replace />;\n    }\n  }\n\n  // User is authenticated and has required roles, render the protected content\n  return <Outlet />;\n};\n\nexport default ProtectedRoute;\n```\n\nUpdate the application routes to use the protected route component:\n\n```typescript\n// src/App.tsx or src/routes/index.tsx\nimport { Routes, Route } from 'react-router-dom';\nimport LoginPage from '../pages/LoginPage';\nimport Dashboard from '../pages/Dashboard';\nimport UnauthorizedPage from '../pages/UnauthorizedPage';\nimport ProtectedRoute from '../components/auth/ProtectedRoute';\n\nconst AppRoutes = () => {\n  return (\n    <Routes>\n      <Route path=\"/login\" element={<LoginPage />} />\n      <Route path=\"/unauthorized\" element={<UnauthorizedPage />} />\n      \n      {/* Protected routes */}\n      <Route element={<ProtectedRoute />}>\n        <Route path=\"/\" element={<Dashboard />} />\n        <Route path=\"/profile\" element={<UserProfile />} />\n      </Route>\n      \n      {/* Role-specific routes */}\n      <Route element={<ProtectedRoute requiredRoles={['Admin']} />}>\n        <Route path=\"/admin\" element={<AdminDashboard />} />\n      </Route>\n    </Routes>\n  );\n};\n\nexport default AppRoutes;\n```",
      "testStrategy": "1. Test that unauthenticated users are redirected to the login page\n2. Verify that the original URL is preserved in the redirect state\n3. Test that authenticated users can access protected routes\n4. Verify that users without required roles are redirected to the unauthorized page\n5. Test loading state while authentication is being verified\n6. Verify that the component works correctly with nested routes",
      "priority": "high",
      "dependencies": [
        2,
        3
      ],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "Implement Authentication State Checking",
          "description": "Create the core functionality to check if a user is authenticated before allowing access to protected routes",
          "dependencies": [],
          "details": "1. Create a ProtectedRoute component that accepts children, authenticationRequired, and redirectPath props\n2. Implement a hook or context consumer to retrieve the current authentication state\n3. Add loading state handling to prevent flickering during authentication checks\n4. Implement conditional rendering logic to either show a loading indicator, the protected content, or trigger a redirect\n5. Test with both authenticated and unauthenticated user scenarios\n6. Document the component with JSDoc comments",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Implement Role-Based Access Control",
          "description": "Add role-based authorization to the ProtectedRoute component to restrict access based on user roles",
          "dependencies": [
            1
          ],
          "details": "1. Extend the ProtectedRoute component to accept allowedRoles prop (array of role strings)\n2. Retrieve the user's role(s) from the authentication context or state\n3. Implement logic to check if the user's role is included in the allowedRoles array\n4. Handle the case where a user is authenticated but lacks the required role\n5. Add a separate redirectPath for unauthorized (authenticated but wrong role) vs unauthenticated users\n6. Test with users having different roles against routes with various role requirements\n7. Add appropriate error messages or notifications for unauthorized access attempts",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Implement Redirection Logic",
          "description": "Create flexible redirection handling for different authentication and authorization scenarios",
          "dependencies": [
            1,
            2
          ],
          "details": "1. Integrate with React Router v6's Navigate component for redirections\n2. Implement state preservation during redirects to return users to their intended destination after login\n3. Add support for custom redirect paths based on different conditions (unauthenticated, unauthorized)\n4. Implement a history tracking mechanism to redirect users back to the page they were trying to access\n5. Add support for custom redirect behavior through render props or callback functions\n6. Test redirection with various scenarios including deep linking and return-to-origin functionality\n7. Ensure redirects maintain URL parameters when appropriate",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Integrate with React Router and Test End-to-End",
          "description": "Finalize the integration with React Router v6 and perform comprehensive testing",
          "dependencies": [
            1,
            2,
            3
          ],
          "details": "1. Create a complete implementation that works with React Router v6's routing system\n2. Implement nested route protection for route hierarchies\n3. Add support for route-specific configuration through React Router's element prop\n4. Create a higher-order component version for class components if needed\n5. Write comprehensive unit tests covering all authentication and authorization scenarios\n6. Create integration tests with React Router to verify correct routing behavior\n7. Document usage patterns with examples for different scenarios (simple auth check, role-based protection, custom redirects)\n8. Create a demo page showcasing different protection scenarios\n9. Perform performance testing to ensure minimal impact on application load time",
          "status": "pending"
        }
      ]
    },
    {
      "id": 7,
      "title": "Update API Service for MSAL Token Integration",
      "description": "Modify the API service to use MSAL tokens for authentication and handle token acquisition and renewal.",
      "details": "Create or update the API service to use MSAL tokens:\n\n```typescript\n// src/services/apiService.ts\nimport axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse, AxiosError } from 'axios';\nimport { msalInstance } from '../auth/MSALProvider';\nimport { loginRequest } from '../auth/msalConfig';\n\nclass ApiService {\n  private api: AxiosInstance;\n  private isAcquiringToken: boolean = false;\n  private tokenAcquisitionPromise: Promise<string | null> | null = null;\n\n  constructor() {\n    this.api = axios.create({\n      baseURL: process.env.REACT_APP_API_URL || '/api',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n    });\n\n    this.setupInterceptors();\n  }\n\n  private setupInterceptors(): void {\n    // Request interceptor to add auth token\n    this.api.interceptors.request.use(\n      async (config) => {\n        const token = await this.getAccessToken();\n        if (token) {\n          config.headers.Authorization = `Bearer ${token}`;\n        }\n        return config;\n      },\n      (error) => Promise.reject(error)\n    );\n\n    // Response interceptor to handle errors\n    this.api.interceptors.response.use(\n      (response) => response,\n      async (error: AxiosError) => {\n        const originalRequest = error.config as AxiosRequestConfig & { _retry?: boolean };\n        \n        // If error is 401 Unauthorized and we haven't retried yet\n        if (error.response?.status === 401 && !originalRequest._retry) {\n          originalRequest._retry = true;\n          \n          try {\n            // Force token refresh\n            const token = await this.getAccessToken(true);\n            if (token) {\n              // Update the authorization header\n              this.api.defaults.headers.common.Authorization = `Bearer ${token}`;\n              if (originalRequest.headers) {\n                originalRequest.headers.Authorization = `Bearer ${token}`;\n              }\n              // Retry the request\n              return this.api(originalRequest);\n            }\n          } catch (refreshError) {\n            console.error('Token refresh failed', refreshError);\n            // Redirect to login if token refresh fails\n            window.location.href = '/login';\n            return Promise.reject(refreshError);\n          }\n        }\n        \n        return Promise.reject(error);\n      }\n    );\n  }\n\n  private async getAccessToken(forceRefresh: boolean = false): Promise<string | null> {\n    // If we're already acquiring a token, return the existing promise\n    if (this.isAcquiringToken && this.tokenAcquisitionPromise) {\n      return this.tokenAcquisitionPromise;\n    }\n\n    this.isAcquiringToken = true;\n    this.tokenAcquisitionPromise = (async () => {\n      try {\n        const accounts = msalInstance.getAllAccounts();\n        if (accounts.length === 0) {\n          return null;\n        }\n\n        const account = accounts[0];\n        let tokenResponse;\n\n        try {\n          // Try silent token acquisition first\n          tokenResponse = await msalInstance.acquireTokenSilent({\n            ...loginRequest,\n            account,\n            forceRefresh\n          });\n        } catch (error: any) {\n          // If silent acquisition fails, try interactive\n          console.warn('Silent token acquisition failed', error);\n          if (error.name === 'InteractionRequiredAuthError') {\n            try {\n              tokenResponse = await msalInstance.acquireTokenPopup(loginRequest);\n            } catch (interactiveError) {\n              console.error('Interactive token acquisition failed', interactiveError);\n              throw interactiveError;\n            }\n          } else {\n            throw error;\n          }\n        }\n\n        return tokenResponse.accessToken;\n      } catch (error) {\n        console.error('Failed to acquire token', error);\n        return null;\n      } finally {\n        this.isAcquiringToken = false;\n        this.tokenAcquisitionPromise = null;\n      }\n    })();\n\n    return this.tokenAcquisitionPromise;\n  }\n\n  // Generic request method\n  public async request<T>(config: AxiosRequestConfig): Promise<T> {\n    try {\n      const response: AxiosResponse<T> = await this.api(config);\n      return response.data;\n    } catch (error) {\n      console.error('API request failed', error);\n      throw error;\n    }\n  }\n\n  // Convenience methods for common HTTP verbs\n  public async get<T>(url: string, config?: AxiosRequestConfig): Promise<T> {\n    return this.request<T>({ ...config, method: 'GET', url });\n  }\n\n  public async post<T>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> {\n    return this.request<T>({ ...config, method: 'POST', url, data });\n  }\n\n  public async put<T>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> {\n    return this.request<T>({ ...config, method: 'PUT', url, data });\n  }\n\n  public async delete<T>(url: string, config?: AxiosRequestConfig): Promise<T> {\n    return this.request<T>({ ...config, method: 'DELETE', url });\n  }\n}\n\n// Create a singleton instance\nconst apiService = new ApiService();\nexport default apiService;\n```",
      "testStrategy": "1. Test that API requests include the authentication token in the headers\n2. Verify token acquisition works correctly for authenticated users\n3. Test token refresh when a 401 error is received\n4. Verify error handling for various API response scenarios\n5. Test the retry mechanism for failed requests due to token expiration\n6. Mock API responses to test different error conditions\n7. Verify that unauthenticated users are redirected to login",
      "priority": "high",
      "dependencies": [
        2,
        3
      ],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "Design API Service Class Structure",
          "description": "Create a modular and extensible service class structure for the API client",
          "dependencies": [],
          "details": "1. Create a base ApiService class that handles common functionality\n2. Design interfaces for request/response types\n3. Implement configuration options (base URL, timeout, headers)\n4. Create service factory for generating API service instances\n5. Document class relationships and responsibilities\n6. Test cases: Verify service instantiation with different configs, validate inheritance structure works correctly",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Implement Token Acquisition Logic",
          "description": "Develop the authentication mechanism to acquire initial access tokens",
          "dependencies": [
            1
          ],
          "details": "1. Create AuthService class for token management\n2. Implement login/authentication endpoint integration\n3. Store tokens securely (access token, refresh token, expiration)\n4. Add token validation methods\n5. Implement token storage persistence\n6. Test cases: Successful token acquisition, handling invalid credentials, token validation checks, persistence across sessions",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Build Request Interceptors",
          "description": "Create interceptors that process outgoing API requests",
          "dependencies": [
            1,
            2
          ],
          "details": "1. Implement request interceptor mechanism\n2. Add authentication header injection\n3. Create request logging functionality\n4. Add request timestamp tracking\n5. Implement request retry configuration\n6. Test cases: Verify auth headers are added correctly, test logging output, confirm retry behavior works",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Develop Response Interceptors with Token Refresh",
          "description": "Create interceptors for API responses with automatic token refresh capability",
          "dependencies": [
            2,
            3
          ],
          "details": "1. Implement response interceptor mechanism\n2. Add token expiration detection\n3. Create token refresh logic\n4. Implement request retry after token refresh\n5. Add concurrency handling for multiple requests during refresh\n6. Test cases: Expired token scenarios, successful refresh and retry, multiple concurrent requests during refresh",
          "status": "pending"
        },
        {
          "id": 5,
          "title": "Implement Comprehensive Error Handling",
          "description": "Create robust error handling for all API service operations",
          "dependencies": [
            3,
            4
          ],
          "details": "1. Design custom error classes for different error types\n2. Implement global error handler\n3. Add specific handlers for auth errors, network errors, and server errors\n4. Create user-friendly error messages\n5. Implement error logging and reporting\n6. Test cases: Authentication failures, network timeouts, server errors, malformed responses, retry exhaustion scenarios",
          "status": "pending"
        }
      ]
    },
    {
      "id": 8,
      "title": "Implement User Profile Component",
      "description": "Create a user profile component that displays information from the Microsoft account and handles user-specific actions.",
      "details": "Create a user profile component that displays user information from MSAL:\n\n```typescript\n// src/components/auth/UserProfile.tsx\nimport React from 'react';\nimport { useMSALAuth } from '../../auth/MSALAuthContext';\nimport './UserProfile.css';\n\ninterface UserProfileProps {\n  showLogout?: boolean;\n  className?: string;\n}\n\nconst UserProfile: React.FC<UserProfileProps> = ({ \n  showLogout = true,\n  className = ''\n}) => {\n  const { user, logout, isLoading } = useMSALAuth();\n\n  if (isLoading) {\n    return <div className=\"user-profile-loading\">Loading...</div>;\n  }\n\n  if (!user) {\n    return null;\n  }\n\n  // Generate initials for avatar fallback\n  const getInitials = () => {\n    if (!user.name) return '?';\n    \n    const nameParts = user.name.split(' ');\n    if (nameParts.length === 1) return nameParts[0].charAt(0).toUpperCase();\n    \n    return (\n      nameParts[0].charAt(0).toUpperCase() + \n      nameParts[nameParts.length - 1].charAt(0).toUpperCase()\n    );\n  };\n\n  const handleLogout = async () => {\n    await logout();\n  };\n\n  return (\n    <div className={`user-profile ${className}`}>\n      <div className=\"user-avatar\">\n        {/* If we had a photo URL from Microsoft Graph, we could use it here */}\n        <div className=\"avatar-initials\">{getInitials()}</div>\n      </div>\n      \n      <div className=\"user-info\">\n        <div className=\"user-name\">{user.name}</div>\n        <div className=\"user-email\">{user.email}</div>\n      </div>\n      \n      {showLogout && (\n        <button \n          className=\"logout-button\" \n          onClick={handleLogout}\n          aria-label=\"Sign out\"\n        >\n          Sign out\n        </button>\n      )}\n    </div>\n  );\n};\n\nexport default UserProfile;\n```\n\nAdd the corresponding CSS:\n\n```css\n/* src/components/auth/UserProfile.css */\n.user-profile {\n  display: flex;\n  align-items: center;\n  padding: 8px;\n  border-radius: 4px;\n}\n\n.user-avatar {\n  width: 40px;\n  height: 40px;\n  border-radius: 50%;\n  overflow: hidden;\n  margin-right: 12px;\n  background-color: #0078d4;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n\n.avatar-initials {\n  color: white;\n  font-size: 16px;\n  font-weight: 600;\n}\n\n.user-info {\n  flex: 1;\n  min-width: 0;\n}\n\n.user-name {\n  font-weight: 600;\n  font-size: 14px;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n\n.user-email {\n  font-size: 12px;\n  color: #666;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n\n.logout-button {\n  background: none;\n  border: none;\n  color: #0078d4;\n  font-size: 14px;\n  cursor: pointer;\n  padding: 4px 8px;\n  margin-left: 8px;\n  border-radius: 4px;\n}\n\n.logout-button:hover {\n  background-color: rgba(0, 120, 212, 0.1);\n  text-decoration: underline;\n}\n\n.user-profile-loading {\n  font-size: 14px;\n  color: #666;\n  padding: 8px;\n}\n\n/* Responsive adjustments */\n@media (max-width: 480px) {\n  .user-info {\n    max-width: 150px;\n  }\n}\n```",
      "testStrategy": "1. Verify that the component correctly displays user information\n2. Test the logout functionality\n3. Verify that the component handles loading states correctly\n4. Test the component with different user data formats\n5. Verify that the initials generation works correctly for different name formats\n6. Test responsive behavior on different screen sizes\n7. Verify accessibility compliance",
      "priority": "medium",
      "dependencies": [
        2,
        3
      ],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "Create User Profile Component Structure",
          "description": "Set up the basic structure of the User Profile component with proper layout and responsive design",
          "dependencies": [],
          "details": "Create a new React component called UserProfile. Implement a container div with appropriate styling for different screen sizes. Include placeholders for user avatar, name, email, and logout button. Use CSS modules or styled-components for styling. Ensure the component has proper TypeScript interfaces for props including user information from MSAL. Add accessibility attributes like aria-labels and proper tab navigation. The component should collapse gracefully on smaller screens.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Implement User Information Display",
          "description": "Display user information from MSAL including name, email, and generate/display user avatar",
          "dependencies": [
            1
          ],
          "details": "Connect the component to MSAL context to retrieve authenticated user data. Display user's display name and email address with appropriate typography. Implement an avatar component that either uses the user's profile picture if available or generates initials-based avatar with a background color. Add hover states for interactive elements. Ensure text has sufficient contrast ratio (minimum 4.5:1) for accessibility. Implement skeleton loading state for when user data is being fetched. Add proper error handling for cases when user data cannot be retrieved.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Add Logout Functionality",
          "description": "Implement logout button with confirmation dialog and proper MSAL integration",
          "dependencies": [
            2
          ],
          "details": "Add a logout button with appropriate styling and icon. Implement a confirmation dialog that appears when logout is clicked. Connect logout action to MSAL's signOut method. Add appropriate loading state during logout process. Ensure keyboard accessibility for the logout flow (can be triggered with Enter key). Add appropriate aria-labels and roles for screen readers. Implement proper focus management after logout dialog appears. Add success/error notifications for logout action. Test the logout flow thoroughly with different MSAL configurations.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 9,
      "title": "Implement Role-Based Authorization",
      "description": "Create a system for role-based access control using Azure AD roles/groups and implement UI components that conditionally render based on user roles.",
      "details": "Create a role-based authorization utility and components:\n\n```typescript\n// src/auth/roleUtils.ts\nimport { useMSALAuth } from './MSALAuthContext';\n\n// Define application roles\nexport enum AppRole {\n  User = 'Application.User',\n  Admin = 'Application.Admin'\n}\n\n// Hook to check if user has a specific role\nexport const useHasRole = (role: AppRole | AppRole[]): boolean => {\n  const { user } = useMSALAuth();\n  \n  if (!user || !user.roles || user.roles.length === 0) {\n    return false;\n  }\n  \n  if (Array.isArray(role)) {\n    return role.some(r => user.roles.includes(r));\n  }\n  \n  return user.roles.includes(role);\n};\n\n// Component for conditional rendering based on roles\nexport const RoleBasedRenderer: React.FC<{\n  roles: AppRole | AppRole[];\n  fallback?: React.ReactNode;\n  children: React.ReactNode;\n}> = ({ roles, fallback = null, children }) => {\n  const hasRequiredRole = useHasRole(roles);\n  \n  return hasRequiredRole ? <>{children}</> : <>{fallback}</>;\n};\n```\n\nExample usage in a component:\n\n```typescript\n// src/components/AdminPanel.tsx\nimport React from 'react';\nimport { RoleBasedRenderer, AppRole } from '../auth/roleUtils';\n\nconst AdminPanel: React.FC = () => {\n  return (\n    <div className=\"admin-panel\">\n      <h2>Application Management</h2>\n      \n      <RoleBasedRenderer \n        roles={AppRole.Admin}\n        fallback={<p>You don't have permission to access these settings.</p>}\n      >\n        <div className=\"admin-controls\">\n          <h3>User Management</h3>\n          <p>Admin-only controls for managing users...</p>\n          \n          {/* Admin-only UI components */}\n        </div>\n      </RoleBasedRenderer>\n    </div>\n  );\n};\n\nexport default AdminPanel;\n```\n\nImplement a higher-order component for role-based protection:\n\n```typescript\n// src/auth/withRoleProtection.tsx\nimport React from 'react';\nimport { Navigate } from 'react-router-dom';\nimport { useMSALAuth } from './MSALAuthContext';\nimport { AppRole } from './roleUtils';\n\nexport const withRoleProtection = (\n  Component: React.ComponentType<any>,\n  requiredRoles: AppRole | AppRole[],\n  redirectPath: string = '/unauthorized'\n) => {\n  const ProtectedComponent: React.FC<any> = (props) => {\n    const { user, isLoading } = useMSALAuth();\n    \n    if (isLoading) {\n      return <div>Loading...</div>;\n    }\n    \n    if (!user) {\n      return <Navigate to=\"/login\" replace />;\n    }\n    \n    const roles = Array.isArray(requiredRoles) ? requiredRoles : [requiredRoles];\n    const hasRequiredRole = roles.some(role => user.roles.includes(role));\n    \n    if (!hasRequiredRole) {\n      return <Navigate to={redirectPath} replace />;\n    }\n    \n    return <Component {...props} />;\n  };\n  \n  return ProtectedComponent;\n};\n```\n\nExample usage of the HOC:\n\n```typescript\n// src/pages/AdminDashboard.tsx\nimport React from 'react';\nimport { withRoleProtection } from '../auth/withRoleProtection';\nimport { AppRole } from '../auth/roleUtils';\n\nconst AdminDashboard: React.FC = () => {\n  return (\n    <div className=\"admin-dashboard\">\n      <h1>Admin Dashboard</h1>\n      {/* Admin-specific content */}\n    </div>\n  );\n};\n\n// Export with role protection\nexport default withRoleProtection(AdminDashboard, AppRole.Admin);\n```",
      "testStrategy": "1. Test that the useHasRole hook correctly identifies user roles\n2. Verify that the RoleBasedRenderer component conditionally renders based on user roles\n3. Test the withRoleProtection HOC with different role configurations\n4. Verify that unauthorized users are redirected to the appropriate page\n5. Test with various role combinations and edge cases\n6. Verify that role-based UI elements are correctly displayed or hidden\n7. Test server-side role validation with API requests",
      "priority": "high",
      "dependencies": [
        2,
        3,
        6
      ],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "Create Role Utilities and Constants",
          "description": "Develop utility functions and constants for role management",
          "dependencies": [],
          "details": "1. Create a roles.js file with constants for all user roles (ADMIN, MANAGER, USER, etc.)\n2. Implement hasRole(user, role) utility to check if a user has a specific role\n3. Implement hasAnyRole(user, roles) to check if user has any of the provided roles\n4. Create getRoles(user) utility to extract roles from user object\n5. Write unit tests for all utility functions with various role combinations\n6. Document the API for these utilities with JSDoc comments",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Implement Conditional Rendering Components",
          "description": "Create React components for conditional rendering based on user roles",
          "dependencies": [
            1
          ],
          "details": "1. Create RoleBasedRenderer component that renders children only if user has required role\n2. Implement RoleSwitch and RoleCase components for rendering different content based on roles\n3. Create useRole() hook to access role information in functional components\n4. Add prop-types validation for all components\n5. Write unit tests for components with different role scenarios\n6. Create usage examples for documentation",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Develop Higher-Order Components for Role Protection",
          "description": "Create HOCs to protect routes and components based on user roles",
          "dependencies": [
            1
          ],
          "details": "1. Implement withRoleProtection HOC to wrap components that should only be accessible to specific roles\n2. Create withRoleRedirect HOC to redirect unauthorized users to appropriate pages\n3. Develop withRoleFallback HOC to show fallback UI for unauthorized users\n4. Integrate HOCs with React Router for protected routes\n5. Write comprehensive tests for each HOC with different authentication states\n6. Create error handling for edge cases (no user, loading states, etc.)",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Integrate Role-Based Authorization with Existing Components",
          "description": "Apply role-based authorization to existing application components",
          "dependencies": [
            1,
            2,
            3
          ],
          "details": "1. Update navigation components to show/hide items based on user roles\n2. Modify existing routes to use role protection HOCs\n3. Add role-based conditional rendering to dashboard and admin panels\n4. Implement role-based feature flags for progressive feature rollout\n5. Create integration tests for the full authorization flow\n6. Update documentation with examples of protected components and routes\n7. Perform security review to ensure no authorization bypasses exist",
          "status": "pending"
        }
      ]
    },
    {
      "id": 10,
      "title": "Implement Token Refresh and Session Management",
      "description": "Create a robust token refresh mechanism to maintain user sessions and handle token expiration gracefully.",
      "details": "Enhance the MSAL authentication context with improved token refresh and session management:\n\n```typescript\n// Add to MSALAuthContext.tsx\n\n// Add these imports\nimport { InteractionRequiredAuthError, AccountInfo, SilentRequest } from '@azure/msal-browser';\n\n// Add these to the MSALAuthProvider component\nconst TOKEN_REFRESH_INTERVAL_MS = 4 * 60 * 1000; // 4 minutes\nconst [refreshIntervalId, setRefreshIntervalId] = useState<NodeJS.Timeout | null>(null);\n\n// Add this function to the MSALAuthProvider component\nconst setupTokenRefresh = (account: AccountInfo) => {\n  // Clear any existing interval\n  if (refreshIntervalId) {\n    clearInterval(refreshIntervalId);\n  }\n  \n  // Set up a new interval for token refresh\n  const intervalId = setInterval(async () => {\n    try {\n      await refreshToken(account);\n    } catch (error) {\n      console.error('Token refresh failed:', error);\n      // If token refresh fails critically, clear the interval and sign out\n      if (error instanceof InteractionRequiredAuthError) {\n        clearInterval(intervalId);\n        setRefreshIntervalId(null);\n        setIsAuthenticated(false);\n        setUser(null);\n        setError('Your session has expired. Please sign in again.');\n      }\n    }\n  }, TOKEN_REFRESH_INTERVAL_MS);\n  \n  setRefreshIntervalId(intervalId);\n  \n  // Clean up interval on component unmount\n  return () => {\n    clearInterval(intervalId);\n    setRefreshIntervalId(null);\n  };\n};\n\n// Add this function to the MSALAuthProvider component\nconst refreshToken = async (account: AccountInfo) => {\n  try {\n    const silentRequest: SilentRequest = {\n      ...loginRequest,\n      account,\n      forceRefresh: false\n    };\n    \n    const response = await msalInstance.acquireTokenSilent(silentRequest);\n    \n    // Update user with new token\n    setUser(prev => prev ? { ...prev, accessToken: response.accessToken } : null);\n    return response.accessToken;\n  } catch (error) {\n    if (error instanceof InteractionRequiredAuthError) {\n      // Silent token acquisition failed, user interaction required\n      throw error;\n    } else {\n      console.error('Token refresh error:', error);\n      // For other errors, we can try again later\n      return null;\n    }\n  }\n};\n\n// Modify the handleSignedInAccount function to set up token refresh\nconst handleSignedInAccount = async (account: AccountInfo) => {\n  try {\n    const tokenResponse = await msalInstance.acquireTokenSilent({\n      ...loginRequest,\n      account\n    });\n    \n    const user = mapAccountToUser(account, tokenResponse);\n    setUser(user);\n    setIsAuthenticated(true);\n    setError(null);\n    \n    // Set up token refresh\n    const cleanup = setupTokenRefresh(account);\n    \n    // Return cleanup function\n    return cleanup;\n  } catch (err) {\n    if (err instanceof InteractionRequiredAuthError) {\n      // Silent token acquisition failed, user interaction required\n      setIsAuthenticated(false);\n      setUser(null);\n    } else {\n      console.error('Token acquisition error', err);\n      setError('Failed to acquire authentication token');\n    }\n  }\n};\n\n// Modify the useEffect to use the cleanup function\nuseEffect(() => {\n  let cleanup: (() => void) | undefined;\n  \n  const initializeAuth = async () => {\n    try {\n      // Handle redirect promise\n      await msalInstance.handleRedirectPromise();\n      \n      // Check if user is already signed in\n      const accounts = msalInstance.getAllAccounts();\n      if (accounts.length > 0) {\n        msalInstance.setActiveAccount(accounts[0]);\n        cleanup = await handleSignedInAccount(accounts[0]);\n      }\n    } catch (err) {\n      console.error('MSAL Initialization Error', err);\n      setError('Failed to initialize authentication');\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  initializeAuth();\n  \n  // Clean up on unmount\n  return () => {\n    if (cleanup) cleanup();\n    if (refreshIntervalId) {\n      clearInterval(refreshIntervalId);\n      setRefreshIntervalId(null);\n    }\n  };\n}, []);\n\n// Modify the logout function to clear the refresh interval\nconst logout = async (): Promise<void> => {\n  try {\n    // Clear token refresh interval\n    if (refreshIntervalId) {\n      clearInterval(refreshIntervalId);\n      setRefreshIntervalId(null);\n    }\n    \n    await msalInstance.logoutPopup();\n    setIsAuthenticated(false);\n    setUser(null);\n  } catch (err) {\n    console.error('Logout error', err);\n    // Even if logout fails, clear local state\n    setIsAuthenticated(false);\n    setUser(null);\n  }\n};\n```",
      "testStrategy": "1. Test that token refresh occurs at the expected intervals\n2. Verify that silent token refresh works correctly\n3. Test error handling when token refresh fails\n4. Verify that the user session is maintained across page refreshes\n5. Test that the refresh interval is cleared on logout\n6. Verify that expired sessions prompt the user to re-authenticate\n7. Test the cleanup function to ensure no memory leaks\n8. Simulate token expiration scenarios to verify proper handling",
      "priority": "high",
      "dependencies": [
        2,
        3,
        7
      ],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "Implement Token Refresh Interval Setup",
          "description": "Create a mechanism to periodically refresh the authentication token before it expires",
          "dependencies": [],
          "details": "1. Create a utility function that calculates the optimal refresh time (75% of token lifetime)\n2. Implement a configurable interval mechanism using setTimeout or setInterval\n3. Store the interval reference for later cleanup\n4. Add configuration options for minimum and maximum refresh intervals\n5. Implement logic to handle token expiration time extraction from JWT\n6. Test with various token expiration scenarios (short-lived tokens, long-lived tokens)\n7. Add logging for refresh scheduling events",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Implement Silent Token Acquisition",
          "description": "Create a mechanism to silently acquire new tokens without disrupting the user experience",
          "dependencies": [
            1
          ],
          "details": "1. Implement a refreshToken function that uses the refresh token to obtain a new access token\n2. Add retry logic with exponential backoff for transient failures\n3. Implement caching to prevent multiple simultaneous refresh attempts\n4. Add event listeners for app focus/visibility changes to trigger refresh when needed\n5. Test token acquisition with mocked API responses\n6. Test concurrent refresh requests handling\n7. Implement proper promise handling to ensure consumers get updated tokens",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Implement Error Handling for Refresh Failures",
          "description": "Create robust error handling for various token refresh failure scenarios",
          "dependencies": [
            2
          ],
          "details": "1. Categorize potential errors (network issues, invalid refresh token, server errors)\n2. Implement specific handlers for each error category\n3. Create a mechanism to notify the application of critical refresh failures\n4. Add logic to force re-authentication when refresh token is invalid or expired\n5. Implement graceful degradation for non-critical errors\n6. Test with simulated network failures, server errors, and invalid tokens\n7. Add comprehensive logging for debugging refresh failures",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Implement Cleanup Mechanisms",
          "description": "Create proper cleanup mechanisms to prevent memory leaks and ensure proper session termination",
          "dependencies": [
            1,
            2
          ],
          "details": "1. Implement a cleanup function to clear all refresh intervals\n2. Add hooks to component lifecycle methods (useEffect cleanup, componentWillUnmount)\n3. Create a session termination function that clears tokens and intervals\n4. Implement proper handling of multiple authentication instances\n5. Test cleanup during navigation, tab closing, and explicit logout\n6. Verify no memory leaks occur during repeated authentication cycles\n7. Add safeguards against calling refresh after cleanup",
          "status": "pending"
        },
        {
          "id": 5,
          "title": "Integrate with Auth Context",
          "description": "Integrate the token refresh mechanism with the authentication context for application-wide access",
          "dependencies": [
            1,
            2,
            3,
            4
          ],
          "details": "1. Update the AuthContext to include token refresh functionality\n2. Expose necessary methods (forceRefresh, getAccessToken, etc.) to consumers\n3. Implement state updates to reflect token status (refreshing, valid, error)\n4. Add context providers and hooks for easy consumption\n5. Create comprehensive documentation for the auth context API\n6. Test integration with protected routes and API calls\n7. Implement example usage patterns for common scenarios",
          "status": "pending"
        }
      ]
    },
    {
      "id": 11,
      "title": "Implement Logout Functionality",
      "description": "Create a comprehensive logout feature that clears local state, MSAL cache, and handles the logout flow.",
      "details": "Enhance the logout functionality in the MSAL authentication context:\n\n```typescript\n// Update the logout function in MSALAuthContext.tsx\n\nconst logout = async (): Promise<void> => {\n  setIsLoading(true);\n  setError(null);\n  \n  try {\n    // Clear token refresh interval if it exists\n    if (refreshIntervalId) {\n      clearInterval(refreshIntervalId);\n      setRefreshIntervalId(null);\n    }\n    \n    // Get all accounts before logout\n    const accounts = msalInstance.getAllAccounts();\n    \n    // Configure logout request\n    const logoutRequest = {\n      account: accounts.length > 0 ? accounts[0] : undefined,\n      postLogoutRedirectUri: window.location.origin,\n      mainWindowRedirectUri: window.location.origin\n    };\n    \n    // Attempt to use popup for logout\n    try {\n      await msalInstance.logoutPopup(logoutRequest);\n    } catch (popupError: any) {\n      console.warn('Popup logout failed, falling back to redirect', popupError);\n      \n      if (popupError.name === 'PopupBlockedError') {\n        // If popup is blocked, use redirect instead\n        msalInstance.logoutRedirect(logoutRequest);\n        return; // Redirect will happen, no need to continue\n      }\n      \n      // For other errors, continue with cleanup\n      console.error('Logout error', popupError);\n    }\n    \n    // Clear application state regardless of MSAL logout success\n    setIsAuthenticated(false);\n    setUser(null);\n    \n    // Clear any stored tokens from localStorage\n    try {\n      localStorage.removeItem('msal.token.keys');\n      localStorage.removeItem('msal.idtoken');\n      // Clear any other application-specific storage\n    } catch (storageError) {\n      console.error('Error clearing local storage', storageError);\n    }\n    \n    // Optionally redirect to login page\n    window.location.href = '/login';\n  } catch (err) {\n    console.error('Logout process error', err);\n    // Even if the process fails, clear local state\n    setIsAuthenticated(false);\n    setUser(null);\n  } finally {\n    setIsLoading(false);\n  }\n};\n```\n\nCreate a dedicated logout page component:\n\n```typescript\n// src/pages/LogoutPage.tsx\nimport React, { useEffect, useState } from 'react';\nimport { useNavigate } from 'react-router-dom';\nimport { useMSALAuth } from '../auth/MSALAuthContext';\n\nconst LogoutPage: React.FC = () => {\n  const { logout, isAuthenticated, isLoading } = useMSALAuth();\n  const [logoutError, setLogoutError] = useState<string | null>(null);\n  const navigate = useNavigate();\n  \n  useEffect(() => {\n    const performLogout = async () => {\n      try {\n        await logout();\n        // Logout successful, will redirect to login page\n      } catch (error: any) {\n        setLogoutError(error.message || 'An error occurred during logout');\n      }\n    };\n    \n    if (!isLoading && isAuthenticated) {\n      performLogout();\n    } else if (!isLoading && !isAuthenticated) {\n      // Already logged out, redirect to login page\n      navigate('/login', { replace: true });\n    }\n  }, [logout, isAuthenticated, isLoading, navigate]);\n  \n  return (\n    <div className=\"logout-page\">\n      <div className=\"logout-container\">\n        <h1>Signing Out</h1>\n        \n        {isLoading ? (\n          <div className=\"loading-indicator\">\n            <span className=\"spinner\"></span>\n            <p>Signing you out...</p>\n          </div>\n        ) : logoutError ? (\n          <div className=\"error-message\">\n            <p>{logoutError}</p>\n            <button \n              onClick={() => navigate('/login', { replace: true })}\n              className=\"return-button\"\n            >\n              Return to Login\n            </button>\n          </div>\n        ) : (\n          <p>You have been successfully signed out.</p>\n        )}\n      </div>\n    </div>\n  );\n};\n\nexport default LogoutPage;\n```\n\nAdd the logout page to routes:\n\n```typescript\n// Update routes in App.tsx or routes/index.tsx\n<Route path=\"/logout\" element={<LogoutPage />} />\n```",
      "testStrategy": "1. Verify that the logout function clears all authentication state\n2. Test that MSAL cache is properly cleared on logout\n3. Verify that token refresh intervals are cleared\n4. Test the fallback from popup to redirect logout\n5. Verify that users are redirected to the login page after logout\n6. Test error handling during the logout process\n7. Verify that the logout page displays appropriate loading and error states\n8. Test that localStorage items are properly cleared",
      "priority": "medium",
      "dependencies": [
        2,
        3,
        8
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 12,
      "title": "Implement Error Handling and User Feedback",
      "description": "Create a comprehensive error handling system for authentication-related errors with clear user feedback.",
      "details": "Create an authentication error handling utility:\n\n```typescript\n// src/auth/authErrorHandler.ts\nimport { AuthError, InteractionRequiredAuthError } from '@azure/msal-browser';\n\nexport enum AuthErrorType {\n  Interaction = 'interaction',\n  Network = 'network',\n  Permissions = 'permissions',\n  Timeout = 'timeout',\n  UserCancelled = 'userCancelled',\n  Generic = 'generic'\n}\n\nexport interface AuthErrorInfo {\n  type: AuthErrorType;\n  message: string;\n  technicalDetails?: string;\n  actionRequired?: string;\n}\n\nexport const handleAuthError = (error: any): AuthErrorInfo => {\n  // Default error info\n  let errorInfo: AuthErrorInfo = {\n    type: AuthErrorType.Generic,\n    message: 'An authentication error occurred.',\n    technicalDetails: error?.message || 'Unknown error',\n    actionRequired: 'Please try again or contact support if the problem persists.'\n  };\n  \n  // Handle MSAL-specific errors\n  if (error instanceof AuthError) {\n    // User cancelled the login\n    if (error.name === 'UserCancelledError') {\n      errorInfo = {\n        type: AuthErrorType.UserCancelled,\n        message: 'Sign-in was cancelled.',\n        technicalDetails: error.message,\n        actionRequired: 'Please complete the sign-in process to access the application.'\n      };\n    }\n    // Popup blocked\n    else if (error.name === 'PopupBlockedError') {\n      errorInfo = {\n        type: AuthErrorType.Interaction,\n        message: 'The sign-in popup was blocked by your browser.',\n        technicalDetails: error.message,\n        actionRequired: 'Please allow popups for this site and try again.'\n      };\n    }\n    // Interaction required\n    else if (error instanceof InteractionRequiredAuthError) {\n      errorInfo = {\n        type: AuthErrorType.Interaction,\n        message: 'Your session has expired or additional authentication is required.',\n        technicalDetails: error.message,\n        actionRequired: 'Please sign in again to continue.'\n      };\n    }\n    // Network error\n    else if (error.name === 'BrowserAuthError' && error.message.includes('network')) {\n      errorInfo = {\n        type: AuthErrorType.Network,\n        message: 'A network error occurred during authentication.',\n        technicalDetails: error.message,\n        actionRequired: 'Please check your internet connection and try again.'\n      };\n    }\n    // Permissions error\n    else if (error.message.includes('AADSTS65001') || error.message.includes('consent')) {\n      errorInfo = {\n        type: AuthErrorType.Permissions,\n        message: 'You don\\'t have permission to access this application.',\n        technicalDetails: error.message,\n        actionRequired: 'Please contact your administrator to request access.'\n      };\n    }\n  }\n  // Handle network errors\n  else if (error instanceof TypeError && error.message.includes('NetworkError')) {\n    errorInfo = {\n      type: AuthErrorType.Network,\n      message: 'Unable to connect to the authentication service.',\n      technicalDetails: error.message,\n      actionRequired: 'Please check your internet connection and try again.'\n    };\n  }\n  // Handle timeout errors\n  else if (error.name === 'TimeoutError' || (error.message && error.message.includes('timeout'))) {\n    errorInfo = {\n      type: AuthErrorType.Timeout,\n      message: 'The authentication request timed out.',\n      technicalDetails: error.message,\n      actionRequired: 'Please try again. If the problem persists, check your internet connection.'\n    };\n  }\n  \n  return errorInfo;\n};\n```\n\nCreate an error display component:\n\n```typescript\n// src/components/auth/AuthErrorDisplay.tsx\nimport React from 'react';\nimport { AuthErrorInfo, AuthErrorType } from '../../auth/authErrorHandler';\nimport './AuthErrorDisplay.css';\n\ninterface AuthErrorDisplayProps {\n  error: AuthErrorInfo;\n  onRetry?: () => void;\n  onDismiss?: () => void;\n  showTechnicalDetails?: boolean;\n}\n\nconst AuthErrorDisplay: React.FC<AuthErrorDisplayProps> = ({\n  error,\n  onRetry,\n  onDismiss,\n  showTechnicalDetails = false\n}) => {\n  // Determine icon based on error type\n  const getErrorIcon = () => {\n    switch (error.type) {\n      case AuthErrorType.Network:\n        return '🌐';\n      case AuthErrorType.Permissions:\n        return '🔒';\n      case AuthErrorType.UserCancelled:\n        return '✋';\n      case AuthErrorType.Timeout:\n        return '⏱️';\n      case AuthErrorType.Interaction:\n        return '🔄';\n      default:\n        return '⚠️';\n    }\n  };\n\n  return (\n    <div className={`auth-error auth-error-${error.type}`}>\n      <div className=\"auth-error-header\">\n        <span className=\"auth-error-icon\">{getErrorIcon()}</span>\n        <h3 className=\"auth-error-title\">{error.message}</h3>\n        {onDismiss && (\n          <button \n            className=\"auth-error-dismiss\" \n            onClick={onDismiss}\n            aria-label=\"Dismiss error\"\n          >\n            ×\n          </button>\n        )}\n      </div>\n      \n      <div className=\"auth-error-content\">\n        <p className=\"auth-error-action\">{error.actionRequired}</p>\n        \n        {showTechnicalDetails && error.technicalDetails && (\n          <details className=\"auth-error-details\">\n            <summary>Technical details</summary>\n            <code>{error.technicalDetails}</code>\n          </details>\n        )}\n        \n        {onRetry && (\n          <button \n            className=\"auth-error-retry\" \n            onClick={onRetry}\n          >\n            Try Again\n          </button>\n        )}\n      </div>\n    </div>\n  );\n};\n\nexport default AuthErrorDisplay;\n```\n\nAdd the corresponding CSS:\n\n```css\n/* src/components/auth/AuthErrorDisplay.css */\n.auth-error {\n  margin: 16px 0;\n  border-radius: 4px;\n  overflow: hidden;\n  border-left: 4px solid #f44336;\n  background-color: #fff;\n  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n}\n\n.auth-error-header {\n  display: flex;\n  align-items: center;\n  padding: 12px 16px;\n  background-color: #ffebee;\n}\n\n.auth-error-icon {\n  font-size: 20px;\n  margin-right: 12px;\n}\n\n.auth-error-title {\n  flex: 1;\n  margin: 0;\n  font-size: 16px;\n  font-weight: 600;\n  color: #d32f2f;\n}\n\n.auth-error-dismiss {\n  background: none;\n  border: none;\n  font-size: 20px;\n  color: #757575;\n  cursor: pointer;\n  padding: 0 4px;\n}\n\n.auth-error-content {\n  padding: 12px 16px;\n}\n\n.auth-error-action {\n  margin: 0 0 12px 0;\n  font-size: 14px;\n  color: #424242;\n}\n\n.auth-error-details {\n  margin-top: 12px;\n  font-size: 13px;\n}\n\n.auth-error-details summary {\n  cursor: pointer;\n  color: #757575;\n  margin-bottom: 8px;\n}\n\n.auth-error-details code {\n  display: block;\n  padding: 8px;\n  background-color: #f5f5f5;\n  border-radius: 4px;\n  overflow-x: auto;\n  font-family: monospace;\n  font-size: 12px;\n  color: #d32f2f;\n}\n\n.auth-error-retry {\n  margin-top: 12px;\n  padding: 8px 16px;\n  background-color: #f5f5f5;\n  border: 1px solid #ddd;\n  border-radius: 4px;\n  font-size: 14px;\n  cursor: pointer;\n  transition: background-color 0.2s;\n}\n\n.auth-error-retry:hover {\n  background-color: #e0e0e0;\n}\n\n/* Error type specific styles */\n.auth-error-network {\n  border-left-color: #2196f3;\n}\n\n.auth-error-network .auth-error-header {\n  background-color: #e3f2fd;\n}\n\n.auth-error-network .auth-error-title {\n  color: #1976d2;\n}\n\n.auth-error-permissions {\n  border-left-color: #ff9800;\n}\n\n.auth-error-permissions .auth-error-header {\n  background-color: #fff3e0;\n}\n\n.auth-error-permissions .auth-error-title {\n  color: #f57c00;\n}\n\n.auth-error-userCancelled {\n  border-left-color: #9e9e9e;\n}\n\n.auth-error-userCancelled .auth-error-header {\n  background-color: #f5f5f5;\n}\n\n.auth-error-userCancelled .auth-error-title {\n  color: #616161;\n}\n\n.auth-error-timeout {\n  border-left-color: #ff5722;\n}\n\n.auth-error-timeout .auth-error-header {\n  background-color: #fbe9e7;\n}\n\n.auth-error-timeout .auth-error-title {\n  color: #e64a19;\n}\n```\n\nUpdate the login page to use the error handler:\n\n```typescript\n// Update LoginPage.tsx\nimport { handleAuthError } from '../auth/authErrorHandler';\nimport AuthErrorDisplay from '../components/auth/AuthErrorDisplay';\n\n// Inside the LoginPage component\nconst [authErrorInfo, setAuthErrorInfo] = useState<AuthErrorInfo | null>(null);\n\n// Replace the existing error handling with:\nconst handleLoginError = (error: any) => {\n  const errorInfo = handleAuthError(error);\n  setAuthErrorInfo(errorInfo);\n};\n\n// Replace the existing error display with:\n{authErrorInfo && (\n  <AuthErrorDisplay\n    error={authErrorInfo}\n    onRetry={() => {\n      setAuthErrorInfo(null);\n      // Attempt login again\n    }}\n    onDismiss={() => setAuthErrorInfo(null)}\n    showTechnicalDetails={process.env.NODE_ENV === 'development'}\n  />\n)}\n```",
      "testStrategy": "1. Test error handling for various authentication error scenarios\n2. Verify that error messages are user-friendly and provide clear guidance\n3. Test the retry functionality for recoverable errors\n4. Verify that technical details are only shown in development mode\n5. Test the error component with different error types to ensure proper styling\n6. Verify that error messages are accessible and meet WCAG standards\n7. Test error dismissal functionality\n8. Verify integration with the login page and other authentication flows",
      "priority": "medium",
      "dependencies": [
        2,
        3,
        5
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 13,
      "title": "Create Unauthorized Access Page",
      "description": "Implement a page to display when users attempt to access resources they don't have permission for.",
      "details": "Create an unauthorized access page component:\n\n```typescript\n// src/pages/UnauthorizedPage.tsx\nimport React from 'react';\nimport { Link, useNavigate } from 'react-router-dom';\nimport { useMSALAuth } from '../auth/MSALAuthContext';\nimport './UnauthorizedPage.css';\n\nconst UnauthorizedPage: React.FC = () => {\n  const { user, logout } = useMSALAuth();\n  const navigate = useNavigate();\n  \n  const handleGoBack = () => {\n    // Navigate back in history\n    navigate(-1);\n  };\n  \n  const handleGoHome = () => {\n    // Navigate to home page\n    navigate('/');\n  };\n  \n  const handleLogout = async () => {\n    await logout();\n    // Will redirect to login page\n  };\n  \n  return (\n    <div className=\"unauthorized-page\">\n      <div className=\"unauthorized-container\">\n        <div className=\"unauthorized-icon\">🔒</div>\n        \n        <h1>Access Denied</h1>\n        \n        <p className=\"unauthorized-message\">\n          You don't have permission to access this resource.\n        </p>\n        \n        {user && (\n          <div className=\"user-info-box\">\n            <p>You are signed in as:</p>\n            <p className=\"user-email\">{user.email}</p>\n            <p className=\"user-roles\">\n              Roles: {user.roles.length > 0 ? user.roles.join(', ') : 'No roles assigned'}\n            </p>\n          </div>\n        )}\n        \n        <p className=\"help-text\">\n          If you believe you should have access to this page, please contact your administrator.\n        </p>\n        \n        <div className=\"action-buttons\">\n          <button \n            className=\"back-button\" \n            onClick={handleGoBack}\n            aria-label=\"Go back\"\n          >\n            Go Back\n          </button>\n          \n          <button \n            className=\"home-button\" \n            onClick={handleGoHome}\n            aria-label=\"Go to home page\"\n          >\n            Go to Home\n          </button>\n          \n          <button \n            className=\"logout-button\" \n            onClick={handleLogout}\n            aria-label=\"Sign out\"\n          >\n            Sign Out\n          </button>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default UnauthorizedPage;\n```\n\nAdd the corresponding CSS:\n\n```css\n/* src/pages/UnauthorizedPage.css */\n.unauthorized-page {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  min-height: 100vh;\n  background-color: #f5f5f5;\n  padding: 20px;\n}\n\n.unauthorized-container {\n  width: 100%;\n  max-width: 500px;\n  padding: 40px;\n  background-color: white;\n  border-radius: 8px;\n  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);\n  text-align: center;\n}\n\n.unauthorized-icon {\n  font-size: 64px;\n  margin-bottom: 24px;\n}\n\n.unauthorized-container h1 {\n  font-size: 28px;\n  color: #d32f2f;\n  margin: 0 0 16px 0;\n}\n\n.unauthorized-message {\n  font-size: 18px;\n  color: #424242;\n  margin-bottom: 24px;\n}\n\n.user-info-box {\n  background-color: #f5f5f5;\n  border-radius: 4px;\n  padding: 16px;\n  margin-bottom: 24px;\n  text-align: left;\n}\n\n.user-email {\n  font-weight: 600;\n  margin: 8px 0;\n}\n\n.user-roles {\n  font-size: 14px;\n  color: #616161;\n  margin: 8px 0 0 0;\n}\n\n.help-text {\n  font-size: 14px;\n  color: #757575;\n  margin-bottom: 24px;\n}\n\n.action-buttons {\n  display: flex;\n  flex-wrap: wrap;\n  justify-content: center;\n  gap: 12px;\n}\n\n.back-button,\n.home-button,\n.logout-button {\n  padding: 10px 16px;\n  border-radius: 4px;\n  font-size: 14px;\n  font-weight: 500;\n  cursor: pointer;\n  transition: background-color 0.2s;\n}\n\n.back-button {\n  background-color: #f5f5f5;\n  border: 1px solid #ddd;\n  color: #424242;\n}\n\n.back-button:hover {\n  background-color: #e0e0e0;\n}\n\n.home-button {\n  background-color: #2196f3;\n  border: none;\n  color: white;\n}\n\n.home-button:hover {\n  background-color: #1976d2;\n}\n\n.logout-button {\n  background-color: #f44336;\n  border: none;\n  color: white;\n}\n\n.logout-button:hover {\n  background-color: #d32f2f;\n}\n\n/* Responsive adjustments */\n@media (max-width: 480px) {\n  .unauthorized-container {\n    padding: 30px 20px;\n  }\n  \n  .action-buttons {\n    flex-direction: column;\n  }\n  \n  .back-button,\n  .home-button,\n  .logout-button {\n    width: 100%;\n  }\n}\n```\n\nAdd the unauthorized page to routes:\n\n```typescript\n// Update routes in App.tsx or routes/index.tsx\n<Route path=\"/unauthorized\" element={<UnauthorizedPage />} />\n```",
      "testStrategy": "1. Verify that the unauthorized page displays correctly\n2. Test the navigation buttons (back, home, logout)\n3. Verify that user information is displayed correctly when available\n4. Test responsive design on different screen sizes\n5. Verify that the page is accessible and meets WCAG standards\n6. Test integration with the protected route component\n7. Verify that users are redirected to this page when accessing resources without proper permissions",
      "priority": "low",
      "dependencies": [
        6,
        9
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 14,
      "title": "Implement Feature Flag for MSAL Authentication",
      "description": "Create a feature flag system to enable/disable MSAL authentication and support gradual transition from legacy authentication.",
      "details": "Create a feature flag configuration file:\n\n```typescript\n// src/config/featureFlags.ts\nexport interface FeatureFlags {\n  useMsalAuth: boolean;\n  // Add other feature flags as needed\n}\n\n// Default feature flags\nconst defaultFeatureFlags: FeatureFlags = {\n  useMsalAuth: true,\n};\n\n// Try to load feature flags from environment variables\nconst loadFeatureFlagsFromEnv = (): Partial<FeatureFlags> => {\n  const flags: Partial<FeatureFlags> = {};\n  \n  if (process.env.REACT_APP_USE_MSAL_AUTH !== undefined) {\n    flags.useMsalAuth = process.env.REACT_APP_USE_MSAL_AUTH === 'true';\n  }\n  \n  return flags;\n};\n\n// Merge default flags with environment-specific flags\nexport const featureFlags: FeatureFlags = {\n  ...defaultFeatureFlags,\n  ...loadFeatureFlagsFromEnv(),\n};\n\n// Hook for accessing feature flags\nimport { useState, useEffect } from 'react';\n\nexport const useFeatureFlag = (flagName: keyof FeatureFlags): boolean => {\n  const [flagValue, setFlagValue] = useState<boolean>(featureFlags[flagName]);\n  \n  useEffect(() => {\n    // This could be extended to fetch flags from a remote source\n    setFlagValue(featureFlags[flagName]);\n  }, [flagName]);\n  \n  return flagValue;\n};\n```\n\nCreate a combined authentication provider that can switch between legacy and MSAL authentication:\n\n```typescript\n// src/auth/CombinedAuthProvider.tsx\nimport React, { ReactNode } from 'react';\nimport { MSALProviderWrapper } from './MSALProvider';\nimport { LegacyAuthProvider } from './LegacyAuthContext'; // Your existing auth provider\nimport { useFeatureFlag } from '../config/featureFlags';\n\ninterface CombinedAuthProviderProps {\n  children: ReactNode;\n}\n\nexport const CombinedAuthProvider: React.FC<CombinedAuthProviderProps> = ({ children }) => {\n  const useMsalAuth = useFeatureFlag('useMsalAuth');\n  \n  return useMsalAuth ? (\n    <MSALProviderWrapper>\n      {children}\n    </MSALProviderWrapper>\n  ) : (\n    <LegacyAuthProvider>\n      {children}\n    </LegacyAuthProvider>\n  );\n};\n```\n\nCreate a combined auth hook that works with both authentication systems:\n\n```typescript\n// src/auth/useAuth.ts\nimport { useContext } from 'react';\nimport { useMSALAuth } from './MSALAuthContext';\nimport { useLegacyAuth } from './LegacyAuthContext'; // Your existing auth hook\nimport { useFeatureFlag } from '../config/featureFlags';\n\n// Define a common interface that both auth systems will conform to\nexport interface AuthState {\n  isAuthenticated: boolean;\n  isLoading: boolean;\n  user: {\n    id: string;\n    name: string;\n    email: string;\n    roles: string[];\n  } | null;\n  error: string | null;\n  login: (username?: string, password?: string) => Promise<void>;\n  logout: () => Promise<void>;\n}\n\nexport const useAuth = (): AuthState => {\n  const useMsalAuth = useFeatureFlag('useMsalAuth');\n  \n  // Get auth state from MSAL\n  const msalAuth = useMSALAuth();\n  \n  // Get auth state from legacy system\n  const legacyAuth = useLegacyAuth();\n  \n  // Return the appropriate auth state based on the feature flag\n  return useMsalAuth ? msalAuth : legacyAuth;\n};\n```\n\nUpdate the application entry point to use the combined provider:\n\n```typescript\n// src/index.tsx or App.tsx\nimport React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport { BrowserRouter } from 'react-router-dom';\nimport App from './App';\nimport { CombinedAuthProvider } from './auth/CombinedAuthProvider';\n\nconst root = ReactDOM.createRoot(document.getElementById('root') as HTMLElement);\n\nroot.render(\n  <React.StrictMode>\n    <BrowserRouter>\n      <CombinedAuthProvider>\n        <App />\n      </CombinedAuthProvider>\n    </BrowserRouter>\n  </React.StrictMode>\n);\n```\n\nCreate a login page that supports both authentication methods:\n\n```typescript\n// Update LoginPage.tsx to support both auth methods\nimport { useFeatureFlag } from '../config/featureFlags';\n\n// Inside the LoginPage component\nconst useMsalAuth = useFeatureFlag('useMsalAuth');\n\n// In the render method\n{useMsalAuth ? (\n  // MSAL login UI\n  <MicrosoftLoginButton \n    onLoginSuccess={handleLoginSuccess}\n    onLoginError={handleLoginError}\n    className=\"login-button\"\n  />\n) : (\n  // Legacy login form\n  <LegacyLoginForm \n    onLoginSuccess={handleLoginSuccess}\n    onLoginError={handleLoginError}\n  />\n)}\n```",
      "testStrategy": "1. Verify that the feature flag system correctly loads flags from environment variables\n2. Test switching between MSAL and legacy authentication\n3. Verify that the combined auth hook returns the correct authentication state\n4. Test that the login page displays the appropriate UI based on the feature flag\n5. Verify that protected routes work with both authentication methods\n6. Test that user roles and permissions are correctly mapped in both systems\n7. Verify that the application can be deployed with either authentication method enabled",
      "priority": "medium",
      "dependencies": [
        2,
        3
      ],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "Implement Feature Flag Configuration System",
          "description": "Create a centralized feature flag system to control authentication method selection",
          "dependencies": [],
          "details": "1. Create a `featureFlags.ts` configuration file in a shared location\n2. Implement a `useFeatureFlag` hook that reads from this configuration\n3. Add an `AUTH_PROVIDER` flag with possible values: 'firebase', 'clerk', 'combined'\n4. Implement environment-based overrides (dev/staging/prod)\n5. Add persistence layer to maintain flag state across sessions\n6. Create unit tests for the feature flag system\n7. Document the feature flag implementation for other developers",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Develop Combined Authentication Provider",
          "description": "Create a provider that can handle both Firebase and Clerk authentication methods",
          "dependencies": [
            1
          ],
          "details": "1. Create a new `CombinedAuthProvider.tsx` component\n2. Implement conditional rendering of either FirebaseAuthProvider or ClerkAuthProvider based on feature flag\n3. Ensure proper initialization of both auth systems\n4. Handle authentication state synchronization between providers\n5. Implement proper cleanup and resource management\n6. Add error handling for provider switching\n7. Create integration tests for provider switching\n8. Test edge cases like switching during active session",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Create Unified Authentication Hook",
          "description": "Develop a unified hook that provides consistent auth interface regardless of provider",
          "dependencies": [
            1,
            2
          ],
          "details": "1. Create `useUnifiedAuth.ts` hook that abstracts provider differences\n2. Implement common methods: login, logout, register, resetPassword, getCurrentUser\n3. Add type definitions that work with both auth systems\n4. Handle provider-specific features gracefully\n5. Add proper error handling and loading states\n6. Implement caching for performance optimization\n7. Create comprehensive unit tests for all auth operations\n8. Document the hook API for other developers",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Adapt UI Components for Authentication Toggle",
          "description": "Update UI components to work with the unified authentication system",
          "dependencies": [
            3
          ],
          "details": "1. Refactor login/signup forms to use the unified auth hook\n2. Update profile management components\n3. Modify protected routes to use the unified auth system\n4. Create admin toggle UI for switching auth providers\n5. Add visual indicators for current auth provider\n6. Implement graceful handling of auth transitions\n7. Add comprehensive UI tests for all auth flows\n8. Test across different browsers and devices\n9. Create user documentation for any visible changes",
          "status": "pending"
        }
      ]
    }
  ]
}