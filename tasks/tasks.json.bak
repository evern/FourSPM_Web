{
  "tasks": [
    {
      "id": 1,
      "title": "Configure Azure AD Application Registration",
      "description": "Create and configure the Azure AD application registration for both SPA and API within the same registration, with appropriate scopes and redirect URIs.",
      "details": "1. Log in to Azure Portal\n2. Navigate to Azure Active Directory > App registrations\n3. Create a new registration for FourSPM_Web\n4. Configure application as a single-tenant or multi-tenant app\n5. Add redirect URIs for both environments:\n   - http://localhost:3000 (development)\n   - https://app.4spm.org (production)\n6. Configure Authentication settings to enable implicit flow and allow access tokens\n7. Create API scopes:\n   - Application.User (for regular users)\n   - Application.Admin (for administrators)\n8. Configure app to have self-permissions to access its own API\n9. Note down the following values for later use:\n   - Application (client) ID\n   - Directory (tenant) ID\n   - Client secret (generate a new one)\n   - API scope identifiers",
      "testStrategy": "1. Verify application registration is visible in Azure Portal\n2. Confirm redirect URIs are correctly configured\n3. Validate that API scopes are properly defined\n4. Test that the application can request its own API scopes\n5. Ensure client secret is generated and accessible",
      "priority": "high",
      "dependencies": [],
      "status": "done",
      "subtasks": [
        {
          "id": 1,
          "title": "Initial Registration Setup",
          "description": "Sign in to the Azure portal, navigate to Microsoft Entra ID, and register a new application by providing a name and selecting supported account types.",
          "dependencies": [],
          "details": "Access the Azure portal with appropriate permissions. Go to Microsoft Entra ID > App registrations > New registration. Enter a meaningful application name and choose the supported account types (e.g., single tenant or multi-tenant).",
          "status": "done"
        },
        {
          "id": 2,
          "title": "Authentication Configuration and Redirect URIs",
          "description": "Configure authentication settings, including specifying redirect URIs and selecting the appropriate client type (confidential or public).",
          "dependencies": [
            1
          ],
          "details": "After registration, go to the Authentication section. Add required redirect URIs for your application (e.g., web, mobile, or SPA). Set the client type and configure advanced settings such as enabling ID tokens if needed.",
          "status": "done"
        },
        {
          "id": 3,
          "title": "API Scope Definition and Permissions",
          "description": "Define API scopes and configure permissions required by the application to access Microsoft Graph or other APIs.",
          "dependencies": [
            2
          ],
          "details": "Navigate to the API permissions section. Add delegated or application permissions as needed. Define custom scopes if the app exposes an API. Grant admin consent if required.",
          "status": "done"
        },
        {
          "id": 4,
          "title": "Secret Management and Documentation",
          "description": "Create and securely store client secrets or certificates, and document all registration details for future reference.",
          "dependencies": [
            3
          ],
          "details": "In the Certificates & secrets section, generate a new client secret or upload a certificate. Record the secret value securely, as it will not be shown again. Document the application (client) ID, tenant ID, redirect URIs, and secret/certificate details.",
          "status": "done"
        }
      ]
    },
    {
      "id": 2,
      "title": "Install Required Frontend Packages",
      "description": "Install and configure the necessary frontend packages for Azure AD authentication, including MSAL libraries for React.",
      "details": "1. Add the following packages to the React application:\n```bash\nnpm install @azure/msal-browser @azure/msal-react --save\n```\n2. Update package.json to ensure compatibility with existing dependencies\n3. Create a configuration file for MSAL settings (src/auth/msalConfig.ts):\n```typescript\nimport { Configuration, LogLevel } from '@azure/msal-browser';\n\nexport const msalConfig: Configuration = {\n  auth: {\n    clientId: 'YOUR_CLIENT_ID', // From Azure AD registration\n    authority: 'https://login.microsoftonline.com/YOUR_TENANT_ID',\n    redirectUri: window.location.origin, // Will be http://localhost:3000 or https://app.4spm.org\n    postLogoutRedirectUri: window.location.origin\n  },\n  cache: {\n    cacheLocation: 'sessionStorage',\n    storeAuthStateInCookie: false\n  },\n  system: {\n    loggerOptions: {\n      loggerCallback: (level, message, containsPii) => {\n        if (containsPii) return;\n        switch (level) {\n          case LogLevel.Error:\n            console.error(message);\n            break;\n          case LogLevel.Warning:\n            console.warn(message);\n            break;\n          case LogLevel.Info:\n            console.info(message);\n            break;\n          case LogLevel.Verbose:\n            console.debug(message);\n            break;\n        }\n      },\n      logLevel: LogLevel.Info\n    }\n  }\n};\n\nexport const loginRequest = {\n  scopes: ['User.Read', 'api://YOUR_CLIENT_ID/Application.User']\n};\n\nexport const adminRequest = {\n  scopes: ['api://YOUR_CLIENT_ID/Application.Admin']\n};\n```\n4. Create environment-specific configuration files for development and production",
      "testStrategy": "1. Verify all packages install without conflicts\n2. Check that TypeScript types are correctly resolved\n3. Validate MSAL configuration file syntax\n4. Ensure environment-specific configurations load correctly",
      "priority": "high",
      "dependencies": [],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 3,
      "title": "Install Required Backend Packages",
      "description": "Configure authentication services in the frontend following the FourSPM UI Development Guidelines and established API architecture patterns, including integration with React Query for token management.",
      "status": "pending",
      "dependencies": [],
      "priority": "high",
      "details": "1. Implement API endpoints for authentication following the API architecture overview:\n   - Create authentication controller endpoints for login, logout, and token refresh\n   - Implement token validation middleware\n   - Set up proper error handling for authentication failures\n\n2. Configure token management services:\n   - Implement secure token storage in the frontend\n   - Create interceptors for automatic token inclusion in API requests\n   - Set up token refresh logic to handle expiration\n\n3. Integrate with React Query for authentication state management:\n   - Create custom hooks for authentication operations\n   - Implement query invalidation on authentication state changes\n   - Set up proper caching strategies for auth-related queries\n\n4. Follow FourSPM UI Development Guidelines for authentication UI components:\n   - Implement protected routes\n   - Create login/logout UI components\n   - Add authentication state indicators in the UI\n\n5. Create environment-specific configurations for development and production",
      "testStrategy": "1. Verify authentication endpoints work correctly with proper request/response handling\n2. Test token management functionality including storage, inclusion in requests, and refresh\n3. Validate React Query integration by checking query invalidation and caching\n4. Test protected routes to ensure they properly restrict access\n5. Verify login/logout flows work end-to-end\n6. Ensure environment-specific configurations load correctly",
      "subtasks": []
    },
    {
      "id": 4,
      "title": "Create Authentication Context Provider",
      "description": "Implement an authentication context provider using React Context API to manage authentication state across the application.",
      "details": "1. Create an authentication context file (src/auth/AuthContext.tsx):\n```typescript\nimport React, { createContext, useContext, useState, useEffect } from 'react';\nimport { useMsal, useAccount, MsalProvider } from '@azure/msal-react';\nimport { PublicClientApplication, AccountInfo, InteractionRequiredAuthError } from '@azure/msal-browser';\nimport { msalConfig, loginRequest } from './msalConfig';\n\ninterface AuthContextProps {\n  isAuthenticated: boolean;\n  user: AccountInfo | null;\n  login: () => Promise<void>;\n  logout: () => Promise<void>;\n  getAccessToken: () => Promise<string | null>;\n  error: string | null;\n}\n\nconst AuthContext = createContext<AuthContextProps | undefined>(undefined);\n\nexport const msalInstance = new PublicClientApplication(msalConfig);\n\nexport const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {\n  const { instance, accounts, inProgress } = useMsal();\n  const account = useAccount(accounts[0] || {});\n  const [isAuthenticated, setIsAuthenticated] = useState<boolean>(false);\n  const [user, setUser] = useState<AccountInfo | null>(null);\n  const [error, setError] = useState<string | null>(null);\n\n  useEffect(() => {\n    if (account) {\n      setIsAuthenticated(true);\n      setUser(account);\n    } else {\n      setIsAuthenticated(false);\n      setUser(null);\n    }\n  }, [account]);\n\n  const login = async (): Promise<void> => {\n    try {\n      await instance.loginPopup(loginRequest);\n    } catch (error) {\n      setError('Login failed: ' + (error instanceof Error ? error.message : String(error)));\n      console.error('Login error:', error);\n    }\n  };\n\n  const logout = async (): Promise<void> => {\n    try {\n      await instance.logoutPopup();\n    } catch (error) {\n      setError('Logout failed: ' + (error instanceof Error ? error.message : String(error)));\n      console.error('Logout error:', error);\n    }\n  };\n\n  const getAccessToken = async (): Promise<string | null> => {\n    if (!account) return null;\n    \n    try {\n      const response = await instance.acquireTokenSilent({\n        ...loginRequest,\n        account: account\n      });\n      return response.accessToken;\n    } catch (error) {\n      if (error instanceof InteractionRequiredAuthError) {\n        try {\n          const response = await instance.acquireTokenPopup(loginRequest);\n          return response.accessToken;\n        } catch (err) {\n          setError('Token acquisition failed: ' + (err instanceof Error ? err.message : String(err)));\n          console.error('Token acquisition error:', err);\n          return null;\n        }\n      }\n      setError('Silent token acquisition failed: ' + (error instanceof Error ? error.message : String(error)));\n      console.error('Silent token acquisition error:', error);\n      return null;\n    }\n  };\n\n  const contextValue: AuthContextProps = {\n    isAuthenticated,\n    user,\n    login,\n    logout,\n    getAccessToken,\n    error\n  };\n\n  return <AuthContext.Provider value={contextValue}>{children}</AuthContext.Provider>;\n};\n\nexport const MsalAuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {\n  return (\n    <MsalProvider instance={msalInstance}>\n      <AuthProvider>{children}</AuthProvider>\n    </MsalProvider>\n  );\n};\n\nexport const useAuth = (): AuthContextProps => {\n  const context = useContext(AuthContext);\n  if (!context) {\n    throw new Error('useAuth must be used within an AuthProvider');\n  }\n  return context;\n};\n```\n2. Update the main application component to use the MsalAuthProvider\n3. Create custom hooks for authentication-related functionality",
      "testStrategy": "1. Test AuthContext initialization\n2. Verify context values are correctly provided\n3. Test login functionality with mock MSAL instance\n4. Test logout functionality with mock MSAL instance\n5. Test token acquisition with mock MSAL instance\n6. Verify error handling for authentication failures",
      "priority": "high",
      "dependencies": [
        2
      ],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "Set up Authentication Context Structure",
          "description": "Create the basic structure for the Authentication Context using React's Context API",
          "dependencies": [],
          "details": "Create AuthContext.tsx file with createContext(), define interface for auth state and context values, and set up initial default values. Include proper TypeScript typing for the context.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Implement Authentication State Management",
          "description": "Set up state management within the AuthProvider component",
          "dependencies": [
            1
          ],
          "details": "Create the AuthProvider component that will wrap the application, implement useState hooks for user data, authentication status, and loading states. Include proper state initialization from localStorage if available.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Develop Authentication Methods",
          "description": "Implement core authentication functions within the provider",
          "dependencies": [
            2
          ],
          "details": "Create login, logout, and register functions that will handle API calls to authentication endpoints. Include proper error handling and loading state management during authentication processes.",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Implement Token Management",
          "description": "Add functionality to handle authentication tokens",
          "dependencies": [
            3
          ],
          "details": "Create methods to store, retrieve, and refresh authentication tokens. Implement token expiration checking and automatic refresh functionality. Set up secure storage of tokens in localStorage or sessionStorage.",
          "status": "pending"
        },
        {
          "id": 5,
          "title": "Create Custom Authentication Hook",
          "description": "Develop a custom hook for consuming the Authentication Context",
          "dependencies": [
            1,
            2,
            3,
            4
          ],
          "details": "Create a useAuth custom hook that will provide easy access to authentication state and methods throughout the application. Include TypeScript typing and error handling if the hook is used outside of the AuthProvider.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 5,
      "title": "Configure Backend Authentication Middleware",
      "description": "Configure ASP.NET Core authentication middleware to validate Azure AD tokens and enforce permission-based authentication for API endpoints.",
      "status": "pending",
      "dependencies": [
        3
      ],
      "priority": "high",
      "details": "1. Update Program.cs or Startup.cs to configure authentication:\n```csharp\nusing Microsoft.AspNetCore.Authentication.JwtBearer;\nusing Microsoft.Identity.Web;\n\nvar builder = WebApplication.CreateBuilder(args);\n\n// Add services to the container.\nbuilder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)\n    .AddMicrosoftIdentityWebApi(builder.Configuration.GetSection(\"AzureAd\"));\n\nbuilder.Services.AddAuthorization(options =>\n{\n    // Create policies for different permissions\n    options.AddPolicy(\"CanViewProjects\", policy =>\n        policy.RequireClaim(\"http://schemas.microsoft.com/identity/claims/scope\", \"Projects.View\"));\n    \n    options.AddPolicy(\"CanEditProjects\", policy =>\n        policy.RequireClaim(\"http://schemas.microsoft.com/identity/claims/scope\", \"Projects.Edit\"));\n        \n    options.AddPolicy(\"CanDeleteProjects\", policy =>\n        policy.RequireClaim(\"http://schemas.microsoft.com/identity/claims/scope\", \"Projects.Delete\"));\n        \n    // Add more granular permission policies as needed\n});\n\n// Configure CORS for the SPA\nbuilder.Services.AddCors(options =>\n{\n    options.AddPolicy(\"default\", policy =>\n    {\n        policy.WithOrigins(\n            \"http://localhost:3000\",\n            \"https://app.4spm.org\")\n            .AllowAnyHeader()\n            .AllowAnyMethod();\n    });\n});\n\nbuilder.Services.AddControllers();\n\n// Register permission service\nbuilder.Services.AddScoped<IPermissionService, PermissionService>();\n\nvar app = builder.Build();\n\n// Configure the HTTP request pipeline.\nif (app.Environment.IsDevelopment())\n{\n    app.UseDeveloperExceptionPage();\n}\nelse\n{\n    app.UseHsts();\n}\n\napp.UseHttpsRedirection();\napp.UseRouting();\napp.UseCors(\"default\");\n\napp.UseAuthentication();\napp.UseAuthorization();\n\napp.MapControllers();\n\napp.Run();\n```\n2. Update existing controller classes to require authentication:\n```csharp\n[Authorize]\n[ApiController]\n[Route(\"api/[controller]\")]\npublic class ProjectsController : ControllerBase\n{\n    private readonly IPermissionService _permissionService;\n    \n    public ProjectsController(IPermissionService permissionService)\n    {\n        _permissionService = permissionService;\n    }\n    \n    // Controller implementation\n}\n```\n3. Add permission-based authorization to specific endpoints:\n```csharp\n[Authorize(Policy = \"CanDeleteProjects\")]\n[HttpDelete(\"{id}\")]\npublic async Task<IActionResult> DeleteProject(int id)\n{\n    // Implementation\n}\n```\n4. Implement a custom permission handler for more complex permission checks:\n```csharp\npublic class PermissionAuthorizationHandler : AuthorizationHandler<PermissionRequirement>\n{\n    private readonly IPermissionService _permissionService;\n    \n    public PermissionAuthorizationHandler(IPermissionService permissionService)\n    {\n        _permissionService = permissionService;\n    }\n    \n    protected override async Task HandleRequirementAsync(\n        AuthorizationHandlerContext context,\n        PermissionRequirement requirement)\n    {\n        var userId = context.User.FindFirst(ClaimTypes.NameIdentifier)?.Value;\n        if (string.IsNullOrEmpty(userId))\n        {\n            return;\n        }\n        \n        var hasPermission = await _permissionService.UserHasPermissionAsync(\n            userId, requirement.Permission);\n            \n        if (hasPermission)\n        {\n            context.Succeed(requirement);\n        }\n    }\n}\n```\n5. Note that the RolesController and permission-based infrastructure has been implemented in the backend. The IPermissionService interface has been implemented and integrated with the RolePermissionsController.",
      "testStrategy": "1. Verify authentication middleware is correctly configured\n2. Test token validation with valid and invalid tokens\n3. Verify CORS configuration works for allowed origins\n4. Test permission-based authorization policies with different token scopes\n5. Ensure unauthenticated requests are properly rejected\n6. Test the custom permission handler with various permission scenarios\n7. Verify integration with the RolePermissionsController\n8. Test granular permissions for different operations (view, edit, delete, etc.)\n9. Verify permission inheritance and hierarchies work correctly\n10. Test the RolesController endpoints for managing roles and permissions",
      "subtasks": [
        {
          "id": 5.1,
          "title": "Implement IPermissionService interface",
          "description": "Create an interface and implementation for the permission service that will handle checking user permissions",
          "status": "completed"
        },
        {
          "id": 5.2,
          "title": "Create permission requirements and handlers",
          "description": "Implement custom authorization requirements and handlers for permission-based access control",
          "status": "pending"
        },
        {
          "id": 5.3,
          "title": "Integrate with RolePermissionsController",
          "description": "Ensure the authentication middleware works with the existing RolePermissionsController to fetch and validate user permissions",
          "status": "completed"
        },
        {
          "id": 5.4,
          "title": "Update API endpoints with permission-based policies",
          "description": "Replace role-based policies with permission-based policies across all API endpoints",
          "status": "pending"
        },
        {
          "id": 5.5,
          "title": "Implement permission caching",
          "description": "Add caching for permission checks to improve performance and reduce database queries",
          "status": "pending"
        },
        {
          "id": 5.6,
          "title": "Implement Role Management UI",
          "description": "Create a user interface for managing roles that will interact with the new RolesController endpoints",
          "status": "pending"
        }
      ]
    },
    {
      "id": 6,
      "title": "Implement API Service with Token Authentication",
      "description": "Update the API service to include authentication tokens in requests and handle authentication-related errors.",
      "details": "1. Create or update the API service to include authentication tokens (src/services/api.ts):\n```typescript\nimport { useAuth } from '../auth/AuthContext';\n\nexport const useApiService = () => {\n  const { getAccessToken } = useAuth();\n  \n  const apiRequest = async <T>(url: string, options: RequestInit = {}): Promise<T> => {\n    const token = await getAccessToken();\n    \n    if (!token) {\n      throw new Error('No authentication token available');\n    }\n    \n    const headers = {\n      ...options.headers,\n      'Authorization': `Bearer ${token}`,\n      'Content-Type': 'application/json'\n    };\n    \n    const response = await fetch(url, {\n      ...options,\n      headers\n    });\n    \n    if (response.status === 401) {\n      // Token might be expired or invalid\n      throw new Error('Authentication failed. Please log in again.');\n    }\n    \n    if (!response.ok) {\n      throw new Error(`API request failed: ${response.statusText}`);\n    }\n    \n    return response.json();\n  };\n  \n  const get = <T>(url: string): Promise<T> => {\n    return apiRequest<T>(url, { method: 'GET' });\n  };\n  \n  const post = <T>(url: string, data: any): Promise<T> => {\n    return apiRequest<T>(url, {\n      method: 'POST',\n      body: JSON.stringify(data)\n    });\n  };\n  \n  const put = <T>(url: string, data: any): Promise<T> => {\n    return apiRequest<T>(url, {\n      method: 'PUT',\n      body: JSON.stringify(data)\n    });\n  };\n  \n  const del = <T>(url: string): Promise<T> => {\n    return apiRequest<T>(url, { method: 'DELETE' });\n  };\n  \n  return { get, post, put, del };\n};\n```\n2. Update existing API calls to use the new service\n3. Implement error handling for authentication failures",
      "testStrategy": "1. Test API requests with valid authentication tokens\n2. Test API requests with invalid or expired tokens\n3. Verify error handling for authentication failures\n4. Test token refresh during API requests\n5. Verify all HTTP methods (GET, POST, PUT, DELETE) work correctly with authentication",
      "priority": "high",
      "dependencies": [
        4
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 7,
      "title": "Create Login and Logout Components",
      "description": "Implement React components for login and logout functionality using MSAL.",
      "details": "1. Create a login button component (src/components/LoginButton.tsx):\n```typescript\nimport React from 'react';\nimport { useAuth } from '../auth/AuthContext';\n\nexport const LoginButton: React.FC = () => {\n  const { isAuthenticated, login, logout } = useAuth();\n\n  const handleAuthClick = async () => {\n    if (isAuthenticated) {\n      await logout();\n    } else {\n      await login();\n    }\n  };\n\n  return (\n    <button \n      onClick={handleAuthClick}\n      className=\"auth-button\"\n    >\n      {isAuthenticated ? 'Sign Out' : 'Sign in with Microsoft'}\n    </button>\n  );\n};\n```\n\n2. Create a user profile component (src/components/UserProfile.tsx):\n```typescript\nimport React from 'react';\nimport { useAuth } from '../auth/AuthContext';\n\nexport const UserProfile: React.FC = () => {\n  const { isAuthenticated, user } = useAuth();\n\n  if (!isAuthenticated || !user) {\n    return null;\n  }\n\n  return (\n    <div className=\"user-profile\">\n      <span className=\"user-name\">{user.name}</span>\n      <span className=\"user-email\">{user.username}</span>\n    </div>\n  );\n};\n```\n\n3. Update the application header to include these components\n4. Style the components to match the application design\n5. Add loading indicators for authentication processes",
      "testStrategy": "1. Test login button in authenticated and unauthenticated states\n2. Verify login flow works correctly\n3. Verify logout flow works correctly\n4. Test user profile display with mock user data\n5. Verify components are responsive on different screen sizes",
      "priority": "medium",
      "dependencies": [
        4
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 8,
      "title": "Implement Protected Routes",
      "description": "Create a higher-order component or route guard to protect routes that require authentication.",
      "details": "1. Create a protected route component (src/components/ProtectedRoute.tsx):\n```typescript\nimport React from 'react';\nimport { Navigate, useLocation } from 'react-router-dom';\nimport { useAuth } from '../auth/AuthContext';\n\ninterface ProtectedRouteProps {\n  children: React.ReactNode;\n  requiredRole?: 'user' | 'admin';\n}\n\nexport const ProtectedRoute: React.FC<ProtectedRouteProps> = ({ \n  children, \n  requiredRole = 'user' \n}) => {\n  const { isAuthenticated, user } = useAuth();\n  const location = useLocation();\n\n  // Check if user is authenticated\n  if (!isAuthenticated) {\n    // Redirect to login page, but save the current location they were trying to go to\n    return <Navigate to=\"/login\" state={{ from: location }} replace />;\n  }\n\n  // For role-based access control (if implemented)\n  if (requiredRole === 'admin' && !user?.roles?.includes('admin')) {\n    // User is authenticated but doesn't have the required role\n    return <Navigate to=\"/unauthorized\" replace />;\n  }\n\n  // User is authenticated and has the required role (if specified)\n  return <>{children}</>;\n};\n```\n\n2. Update the application routes to use the protected route component:\n```typescript\nimport { BrowserRouter, Routes, Route } from 'react-router-dom';\nimport { ProtectedRoute } from './components/ProtectedRoute';\nimport { Dashboard } from './pages/Dashboard';\nimport { AdminPanel } from './pages/AdminPanel';\nimport { Login } from './pages/Login';\nimport { Unauthorized } from './pages/Unauthorized';\n\nexport const AppRoutes = () => {\n  return (\n    <BrowserRouter>\n      <Routes>\n        <Route path=\"/login\" element={<Login />} />\n        <Route path=\"/unauthorized\" element={<Unauthorized />} />\n        <Route \n          path=\"/dashboard\" \n          element={\n            <ProtectedRoute>\n              <Dashboard />\n            </ProtectedRoute>\n          } \n        />\n        <Route \n          path=\"/admin\" \n          element={\n            <ProtectedRoute requiredRole=\"admin\">\n              <AdminPanel />\n            </ProtectedRoute>\n          } \n        />\n      </Routes>\n    </BrowserRouter>\n  );\n};\n```\n\n3. Create login, unauthorized, and other necessary pages\n4. Implement redirect logic to return users to their intended destination after login",
      "testStrategy": "1. Test protected routes with authenticated and unauthenticated users\n2. Verify redirect to login page works correctly\n3. Test role-based route protection\n4. Verify redirect back to original destination after login\n5. Test edge cases like direct URL access to protected routes",
      "priority": "medium",
      "dependencies": [
        4
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 9,
      "title": "Implement Token Refresh Logic",
      "description": "Create logic to automatically refresh authentication tokens before they expire to maintain user sessions.",
      "details": "1. Enhance the AuthContext to include token refresh logic:\n```typescript\n// Add to AuthContext.tsx\nimport { useEffect, useCallback } from 'react';\n\n// Inside the AuthProvider component\nconst [tokenExpiresAt, setTokenExpiresAt] = useState<number | null>(null);\n\nconst acquireTokenSilently = useCallback(async (): Promise<string | null> => {\n  if (!account) return null;\n  \n  try {\n    const response = await instance.acquireTokenSilent({\n      ...loginRequest,\n      account: account\n    });\n    \n    // Calculate token expiration time (typically in seconds)\n    // MSAL doesn't directly provide expiration, so we need to decode the JWT\n    const tokenClaims = JSON.parse(atob(response.accessToken.split('.')[1]));\n    if (tokenClaims.exp) {\n      setTokenExpiresAt(tokenClaims.exp * 1000); // Convert to milliseconds\n    }\n    \n    return response.accessToken;\n  } catch (error) {\n    if (error instanceof InteractionRequiredAuthError) {\n      // User interaction required, handle accordingly\n      setError('Interactive login required');\n      return null;\n    }\n    \n    setError('Silent token acquisition failed: ' + (error instanceof Error ? error.message : String(error)));\n    console.error('Silent token acquisition error:', error);\n    return null;\n  }\n}, [account, instance]);\n\n// Set up token refresh timer\nuseEffect(() => {\n  if (!isAuthenticated || !tokenExpiresAt) return;\n  \n  // Refresh token 5 minutes before expiration\n  const timeUntilRefresh = tokenExpiresAt - Date.now() - (5 * 60 * 1000);\n  \n  // Don't set a timer if the token is already expired or about to expire\n  if (timeUntilRefresh <= 0) {\n    acquireTokenSilently();\n    return;\n  }\n  \n  const refreshTimer = setTimeout(() => {\n    acquireTokenSilently();\n  }, timeUntilRefresh);\n  \n  return () => clearTimeout(refreshTimer);\n}, [isAuthenticated, tokenExpiresAt, acquireTokenSilently]);\n```\n\n2. Update the getAccessToken method to use the acquireTokenSilently function\n3. Add error handling for token refresh failures\n4. Implement retry logic for failed token refreshes",
      "testStrategy": "1. Test token refresh before expiration\n2. Verify token expiration calculation\n3. Test error handling for refresh failures\n4. Verify automatic refresh works without user interaction\n5. Test retry logic for failed refreshes",
      "priority": "medium",
      "dependencies": [
        4,
        6
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 10,
      "title": "Update User Database Model",
      "description": "Update the database model to integrate with Azure AD user identities and store necessary user information.",
      "details": "1. Update the User entity model to include Azure AD identifiers:\n```csharp\npublic class User\n{\n    public int Id { get; set; }\n    \n    // Azure AD specific fields\n    public string AzureAdObjectId { get; set; } // The unique identifier from Azure AD\n    public string Email { get; set; }\n    public string DisplayName { get; set; }\n    \n    // Existing application-specific fields\n    public DateTime CreatedAt { get; set; }\n    public DateTime? LastLoginAt { get; set; }\n    public bool IsActive { get; set; }\n    \n    // Navigation properties\n    public virtual ICollection<UserRole> UserRoles { get; set; }\n    // Other navigation properties as needed\n}\n```\n\n2. Create or update database migration:\n```csharp\npublic partial class AddAzureAdFields : Migration\n{\n    protected override void Up(MigrationBuilder migrationBuilder)\n    {\n        migrationBuilder.AddColumn<string>(\n            name: \"AzureAdObjectId\",\n            table: \"Users\",\n            type: \"nvarchar(128)\",\n            maxLength: 128,\n            nullable: true);\n\n        migrationBuilder.AddColumn<string>(\n            name: \"Email\",\n            table: \"Users\",\n            type: \"nvarchar(256)\",\n            maxLength: 256,\n            nullable: true);\n\n        migrationBuilder.AddColumn<string>(\n            name: \"DisplayName\",\n            table: \"Users\",\n            type: \"nvarchar(256)\",\n            maxLength: 256,\n            nullable: true);\n\n        // Create a unique index on AzureAdObjectId\n        migrationBuilder.CreateIndex(\n            name: \"IX_Users_AzureAdObjectId\",\n            table: \"Users\",\n            column: \"AzureAdObjectId\",\n            unique: true,\n            filter: \"[AzureAdObjectId] IS NOT NULL\");\n    }\n\n    protected override void Down(MigrationBuilder migrationBuilder)\n    {\n        migrationBuilder.DropIndex(\n            name: \"IX_Users_AzureAdObjectId\",\n            table: \"Users\");\n\n        migrationBuilder.DropColumn(\n            name: \"AzureAdObjectId\",\n            table: \"Users\");\n\n        migrationBuilder.DropColumn(\n            name: \"Email\",\n            table: \"Users\");\n\n        migrationBuilder.DropColumn(\n            name: \"DisplayName\",\n            table: \"Users\");\n    }\n}\n```\n\n3. Update the user repository to find users by Azure AD Object ID:\n```csharp\npublic async Task<User> GetUserByAzureAdObjectIdAsync(string azureAdObjectId)\n{\n    return await _context.Users\n        .Include(u => u.UserRoles)\n        .ThenInclude(ur => ur.Role)\n        .FirstOrDefaultAsync(u => u.AzureAdObjectId == azureAdObjectId);\n}\n```\n\n4. Implement logic to create or update user records based on Azure AD information",
      "testStrategy": "1. Test database migrations\n2. Verify user lookup by Azure AD Object ID\n3. Test user creation with Azure AD information\n4. Verify existing user data is preserved during migration\n5. Test database queries with the updated model",
      "priority": "medium",
      "dependencies": [
        5
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 11,
      "title": "Implement User Service Integration",
      "description": "Create or update the user service to integrate with Azure AD authentication and manage user information.",
      "details": "1. Create or update the user service to handle Azure AD user information:\n```csharp\npublic class UserService : IUserService\n{\n    private readonly ApplicationDbContext _context;\n    private readonly ILogger<UserService> _logger;\n\n    public UserService(ApplicationDbContext context, ILogger<UserService> logger)\n    {\n        _context = context;\n        _logger = logger;\n    }\n\n    public async Task<User> GetOrCreateUserAsync(ClaimsPrincipal claimsPrincipal)\n    {\n        // Extract Azure AD object ID from claims\n        var objectId = claimsPrincipal.FindFirstValue(\"http://schemas.microsoft.com/identity/claims/objectidentifier\");\n        if (string.IsNullOrEmpty(objectId))\n        {\n            _logger.LogWarning(\"No object ID found in claims\");\n            throw new InvalidOperationException(\"User identity not found\");\n        }\n\n        // Try to find existing user\n        var user = await _context.Users\n            .Include(u => u.UserRoles)\n            .ThenInclude(ur => ur.Role)\n            .FirstOrDefaultAsync(u => u.AzureAdObjectId == objectId);\n\n        if (user == null)\n        {\n            // Create new user from claims\n            user = new User\n            {\n                AzureAdObjectId = objectId,\n                Email = claimsPrincipal.FindFirstValue(\"preferred_username\") ?? \n                       claimsPrincipal.FindFirstValue(ClaimTypes.Email) ?? \n                       claimsPrincipal.FindFirstValue(ClaimTypes.Name),\n                DisplayName = claimsPrincipal.FindFirstValue(\"name\") ?? \n                             claimsPrincipal.FindFirstValue(ClaimTypes.GivenName),\n                CreatedAt = DateTime.UtcNow,\n                IsActive = true,\n                UserRoles = new List<UserRole>()\n            };\n\n            // Assign default role\n            var defaultRole = await _context.Roles.FirstOrDefaultAsync(r => r.Name == \"User\");\n            if (defaultRole != null)\n            {\n                user.UserRoles.Add(new UserRole { RoleId = defaultRole.Id });\n            }\n\n            _context.Users.Add(user);\n            await _context.SaveChangesAsync();\n            _logger.LogInformation(\"Created new user from Azure AD: {Email}\", user.Email);\n        }\n        else\n        {\n            // Update existing user information if needed\n            bool updated = false;\n            var email = claimsPrincipal.FindFirstValue(\"preferred_username\") ?? \n                       claimsPrincipal.FindFirstValue(ClaimTypes.Email) ?? \n                       claimsPrincipal.FindFirstValue(ClaimTypes.Name);\n            var displayName = claimsPrincipal.FindFirstValue(\"name\") ?? \n                             claimsPrincipal.FindFirstValue(ClaimTypes.GivenName);\n\n            if (email != null && user.Email != email)\n            {\n                user.Email = email;\n                updated = true;\n            }\n\n            if (displayName != null && user.DisplayName != displayName)\n            {\n                user.DisplayName = displayName;\n                updated = true;\n            }\n\n            user.LastLoginAt = DateTime.UtcNow;\n            updated = true;\n\n            if (updated)\n            {\n                await _context.SaveChangesAsync();\n                _logger.LogInformation(\"Updated user information for: {Email}\", user.Email);\n            }\n        }\n\n        return user;\n    }\n\n    // Other user service methods\n}\n```\n\n2. Register the user service in the dependency injection container:\n```csharp\nbuilder.Services.AddScoped<IUserService, UserService>();\n```\n\n3. Update controllers to use the user service for getting current user information:\n```csharp\n[Authorize]\n[ApiController]\n[Route(\"api/[controller]\")]\npublic class UserController : ControllerBase\n{\n    private readonly IUserService _userService;\n\n    public UserController(IUserService userService)\n    {\n        _userService = userService;\n    }\n\n    [HttpGet(\"me\")]\n    public async Task<ActionResult<UserDto>> GetCurrentUser()\n    {\n        var user = await _userService.GetOrCreateUserAsync(User);\n        return Ok(new UserDto\n        {\n            Id = user.Id,\n            Email = user.Email,\n            DisplayName = user.DisplayName,\n            Roles = user.UserRoles.Select(ur => ur.Role.Name).ToList()\n        });\n    }\n\n    // Other user-related endpoints\n}\n```",
      "testStrategy": "1. Test user creation from Azure AD claims\n2. Verify user information is correctly extracted from claims\n3. Test user lookup by Azure AD Object ID\n4. Verify user information is updated correctly\n5. Test role assignment for new users\n6. Test the current user endpoint with authenticated requests",
      "priority": "medium",
      "dependencies": [
        5,
        10
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 12,
      "title": "Implement Error Handling for Authentication",
      "description": "Create comprehensive error handling for authentication-related errors, including clear user messages and logging.",
      "details": "1. Create an authentication error component (src/components/AuthError.tsx):\n```typescript\nimport React from 'react';\nimport { useAuth } from '../auth/AuthContext';\n\nexport const AuthError: React.FC = () => {\n  const { error } = useAuth();\n\n  if (!error) {\n    return null;\n  }\n\n  return (\n    <div className=\"auth-error-container\">\n      <div className=\"auth-error-message\">\n        <h3>Authentication Error</h3>\n        <p>{error}</p>\n        <button onClick={() => window.location.reload()}>Retry</button>\n      </div>\n    </div>\n  );\n};\n```\n\n2. Update the API service to handle specific authentication errors:\n```typescript\n// Add to api.ts\nconst handleApiError = (error: any) => {\n  // Check if it's an authentication error\n  if (error.message && (\n    error.message.includes('authentication') ||\n    error.message.includes('token') ||\n    error.message.includes('401')\n  )) {\n    // Log the error\n    console.error('Authentication error:', error);\n    \n    // You might want to trigger a re-authentication here\n    // or redirect to login page\n    window.location.href = '/login?error=session_expired';\n    \n    return new Error('Your session has expired. Please log in again.');\n  }\n  \n  // Handle other API errors\n  console.error('API error:', error);\n  return error;\n};\n\n// Update the apiRequest function to use the error handler\nconst apiRequest = async <T>(url: string, options: RequestInit = {}): Promise<T> => {\n  try {\n    // Existing code...\n  } catch (error) {\n    throw handleApiError(error);\n  }\n};\n```\n\n3. Create a login page that handles error parameters:\n```typescript\nimport React, { useEffect, useState } from 'react';\nimport { useLocation, useNavigate } from 'react-router-dom';\nimport { useAuth } from '../auth/AuthContext';\nimport { LoginButton } from '../components/LoginButton';\n\nexport const Login: React.FC = () => {\n  const { isAuthenticated } = useAuth();\n  const location = useLocation();\n  const navigate = useNavigate();\n  const [errorMessage, setErrorMessage] = useState<string | null>(null);\n  \n  // Check for error parameters in the URL\n  useEffect(() => {\n    const params = new URLSearchParams(location.search);\n    const error = params.get('error');\n    \n    if (error === 'session_expired') {\n      setErrorMessage('Your session has expired. Please log in again.');\n    } else if (error) {\n      setErrorMessage('An authentication error occurred. Please try again.');\n    }\n  }, [location]);\n  \n  // Redirect if already authenticated\n  useEffect(() => {\n    if (isAuthenticated) {\n      const from = location.state?.from?.pathname || '/';\n      navigate(from, { replace: true });\n    }\n  }, [isAuthenticated, location.state, navigate]);\n  \n  return (\n    <div className=\"login-container\">\n      <h1>Welcome to FourSPM</h1>\n      \n      {errorMessage && (\n        <div className=\"error-message\">{errorMessage}</div>\n      )}\n      \n      <div className=\"login-box\">\n        <p>Please sign in to continue:</p>\n        <LoginButton />\n      </div>\n    </div>\n  );\n};\n```\n\n4. Implement server-side error logging for authentication failures:\n```csharp\n// Add to Program.cs or a middleware\napp.Use(async (context, next) => {\n    try\n    {\n        await next();\n        \n        // Log authentication failures\n        if (context.Response.StatusCode == 401)\n        {\n            var logger = context.RequestServices.GetRequiredService<ILogger<Program>>();\n            logger.LogWarning(\n                \"Authentication failure for request {Method} {Path}\", \n                context.Request.Method, \n                context.Request.Path);\n        }\n    }\n    catch (Exception ex)\n    {\n        var logger = context.RequestServices.GetRequiredService<ILogger<Program>>();\n        logger.LogError(ex, \"An unhandled exception occurred\");\n        throw;\n    }\n});\n```",
      "testStrategy": "1. Test error display for various authentication errors\n2. Verify error handling for expired tokens\n3. Test error handling for invalid tokens\n4. Verify error messages are user-friendly\n5. Test server-side error logging\n6. Verify redirect to login page with error parameters works correctly",
      "priority": "medium",
      "dependencies": [
        4,
        6,
        7
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 13,
      "title": "Implement Session Persistence",
      "description": "Ensure authentication state persists across page refreshes and browser sessions as required.",
      "details": "1. Update MSAL configuration to use sessionStorage for token caching:\n```typescript\n// In msalConfig.ts\nexport const msalConfig: Configuration = {\n  auth: {\n    // Auth configuration...\n  },\n  cache: {\n    cacheLocation: 'sessionStorage', // Use sessionStorage instead of localStorage for better security\n    storeAuthStateInCookie: false // Set to true for IE11 support if needed\n  },\n  // Other configuration...\n};\n```\n\n2. Add a session check on application startup:\n```typescript\n// In App.tsx or main component\nimport { useEffect, useState } from 'react';\nimport { useAuth } from './auth/AuthContext';\n\nconst App: React.FC = () => {\n  const { isAuthenticated, login } = useAuth();\n  const [isCheckingSession, setIsCheckingSession] = useState(true);\n  \n  useEffect(() => {\n    const checkSession = async () => {\n      try {\n        // MSAL will automatically try to restore the session from cache\n        // We just need to wait for the authentication state to be determined\n        setIsCheckingSession(false);\n      } catch (error) {\n        console.error('Session check failed:', error);\n        setIsCheckingSession(false);\n      }\n    };\n    \n    checkSession();\n  }, []);\n  \n  if (isCheckingSession) {\n    return <div>Loading...</div>;\n  }\n  \n  return (\n    // Application content\n  );\n};\n```\n\n3. Implement a session timeout handler:\n```typescript\n// Add to AuthContext.tsx\nconst handleSessionTimeout = useCallback(() => {\n  // Clear local auth state\n  setIsAuthenticated(false);\n  setUser(null);\n  \n  // Redirect to login page with error\n  window.location.href = '/login?error=session_timeout';\n}, []);\n\n// Add event listener for storage events (for multi-tab coordination)\nuseEffect(() => {\n  const handleStorageChange = (event: StorageEvent) => {\n    // If another tab clears the auth session, log out this tab too\n    if (event.key === null && event.storageArea === sessionStorage) {\n      handleSessionTimeout();\n    }\n  };\n  \n  window.addEventListener('storage', handleStorageChange);\n  return () => window.removeEventListener('storage', handleStorageChange);\n}, [handleSessionTimeout]);\n```\n\n4. Add activity monitoring to extend session during active use:\n```typescript\n// Add to a common layout component\nimport { useEffect } from 'react';\nimport { useAuth } from '../auth/AuthContext';\n\nexport const Layout: React.FC<{ children: React.ReactNode }> = ({ children }) => {\n  const { getAccessToken } = useAuth();\n  \n  useEffect(() => {\n    // Refresh token on user activity to prevent timeout during active use\n    const activityEvents = ['mousedown', 'keydown', 'touchstart', 'scroll'];\n    let activityTimeout: NodeJS.Timeout | null = null;\n    \n    const handleUserActivity = () => {\n      // Debounce token refresh to avoid too many requests\n      if (activityTimeout) {\n        clearTimeout(activityTimeout);\n      }\n      \n      activityTimeout = setTimeout(() => {\n        // Silently refresh the token\n        getAccessToken().catch(err => console.error('Token refresh failed:', err));\n      }, 5000); // 5 second debounce\n    };\n    \n    // Add event listeners\n    activityEvents.forEach(event => {\n      window.addEventListener(event, handleUserActivity);\n    });\n    \n    return () => {\n      // Clean up event listeners\n      activityEvents.forEach(event => {\n        window.removeEventListener(event, handleUserActivity);\n      });\n      \n      if (activityTimeout) {\n        clearTimeout(activityTimeout);\n      }\n    };\n  }, [getAccessToken]);\n  \n  return <div className=\"layout\">{children}</div>;\n};\n```",
      "testStrategy": "1. Test session persistence across page refreshes\n2. Verify authentication state is correctly restored from sessionStorage\n3. Test multi-tab coordination for logout\n4. Verify session timeout handling\n5. Test activity monitoring for session extension\n6. Verify session persistence works in different browsers",
      "priority": "medium",
      "dependencies": [
        4,
        9
      ],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "Configure Token Storage Mechanism",
          "description": "Implement a secure storage mechanism for authentication tokens that persists across page refreshes",
          "dependencies": [],
          "details": "Select and implement an appropriate token storage method (cookies, localStorage, or sessionStorage) based on security requirements. Ensure tokens are properly encrypted and include necessary metadata for validation. Configure expiration settings aligned with the application's security policies.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Develop Session Restoration Logic",
          "description": "Create logic to automatically restore user sessions when returning to the application",
          "dependencies": [
            1
          ],
          "details": "Implement functions to retrieve stored tokens on application load, validate token integrity and expiration, handle token refresh if needed, and restore the user's authenticated state. Include error handling for invalid or expired tokens that redirects users to login.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Implement Session Timeout Handling",
          "description": "Create mechanisms to manage session timeouts and expirations",
          "dependencies": [
            2
          ],
          "details": "Develop logic to track session idle time, display timeout warnings to users, implement automatic logout after specified idle periods, and provide options for users to extend their sessions. Configure server-side validation of session timeouts for security.",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Build Multi-Tab Session Coordination",
          "description": "Ensure consistent session state across multiple browser tabs or windows",
          "dependencies": [
            2,
            3
          ],
          "details": "Implement cross-tab communication using browser storage events or a similar mechanism to synchronize session state. Ensure logout in one tab triggers logout in all tabs, and session extensions in one tab update across all tabs. Handle edge cases like offline tabs.",
          "status": "pending"
        },
        {
          "id": 5,
          "title": "Create User Activity Monitoring System",
          "description": "Develop a system to track and respond to user activity for session management",
          "dependencies": [
            3,
            4
          ],
          "details": "Implement event listeners for user interactions that reset idle timers, create logging mechanisms for session-related events for security auditing, and develop analytics to track session patterns. Include configurable thresholds for different types of user activities.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 14,
      "title": "Implement Role-Based Access Control",
      "description": "Implement role-based access control using Azure AD groups and application roles.",
      "details": "1. Configure application roles in Azure AD:\n   - In the Azure portal, navigate to Azure AD > App registrations > [Your app] > App roles\n   - Create roles for 'User' and 'Admin'\n   - Assign users to these roles in Azure AD\n\n2. Update the backend to extract roles from tokens:\n```csharp\n// Add to UserService.cs\nprivate List<string> GetUserRolesFromClaims(ClaimsPrincipal claimsPrincipal)\n{\n    var roles = new List<string>();\n    \n    // Check for role claims\n    var roleClaims = claimsPrincipal.FindAll(ClaimTypes.Role).ToList();\n    if (roleClaims.Any())\n    {\n        roles.AddRange(roleClaims.Select(c => c.Value));\n    }\n    \n    // Check for app role claims (from Azure AD app roles)\n    var appRoleClaims = claimsPrincipal.FindAll(\"http://schemas.microsoft.com/ws/2008/06/identity/claims/role\").ToList();\n    if (appRoleClaims.Any())\n    {\n        roles.AddRange(appRoleClaims.Select(c => c.Value));\n    }\n    \n    // If no roles found, assign default role\n    if (!roles.Any())\n    {\n        roles.Add(\"User\");\n    }\n    \n    return roles.Distinct().ToList();\n}\n\n// Update GetOrCreateUserAsync method to use roles from claims\npublic async Task<User> GetOrCreateUserAsync(ClaimsPrincipal claimsPrincipal)\n{\n    // Existing code...\n    \n    if (user == null)\n    {\n        // Create new user...\n        \n        // Assign roles from claims\n        var userRoles = GetUserRolesFromClaims(claimsPrincipal);\n        foreach (var roleName in userRoles)\n        {\n            var role = await _context.Roles.FirstOrDefaultAsync(r => r.Name == roleName);\n            if (role != null)\n            {\n                user.UserRoles.Add(new UserRole { RoleId = role.Id });\n            }\n        }\n        \n        // Save user...\n    }\n    else\n    {\n        // Update existing user...\n        \n        // Update roles if needed\n        var currentRoles = user.UserRoles.Select(ur => ur.Role.Name).ToList();\n        var claimRoles = GetUserRolesFromClaims(claimsPrincipal);\n        \n        // Add missing roles\n        foreach (var roleName in claimRoles.Except(currentRoles))\n        {\n            var role = await _context.Roles.FirstOrDefaultAsync(r => r.Name == roleName);\n            if (role != null)\n            {\n                user.UserRoles.Add(new UserRole { RoleId = role.Id });\n                updated = true;\n            }\n        }\n        \n        // Remove roles that are no longer assigned\n        foreach (var userRole in user.UserRoles.ToList())\n        {\n            if (!claimRoles.Contains(userRole.Role.Name))\n            {\n                user.UserRoles.Remove(userRole);\n                updated = true;\n            }\n        }\n        \n        // Save changes...\n    }\n    \n    return user;\n}\n```\n\n3. Update authorization policies to use roles:\n```csharp\n// In Program.cs or Startup.cs\nbuilder.Services.AddAuthorization(options =>\n{\n    options.AddPolicy(\"RequireUserRole\", policy =>\n        policy.RequireRole(\"User\"));\n    \n    options.AddPolicy(\"RequireAdminRole\", policy =>\n        policy.RequireRole(\"Admin\"));\n});\n```\n\n4. Update frontend to handle role-based UI rendering:\n```typescript\n// Add to AuthContext.tsx\nconst [userRoles, setUserRoles] = useState<string[]>([]);\n\n// Update after authentication\nuseEffect(() => {\n  if (isAuthenticated && user) {\n    // Extract roles from ID token claims if available\n    const idTokenClaims = user.idTokenClaims;\n    if (idTokenClaims && idTokenClaims.roles) {\n      setUserRoles(idTokenClaims.roles as string[]);\n    } else {\n      // Fallback: fetch roles from user API\n      apiService.get('/api/user/me')\n        .then(userData => {\n          if (userData.roles) {\n            setUserRoles(userData.roles);\n          }\n        })\n        .catch(error => {\n          console.error('Failed to fetch user roles:', error);\n          setUserRoles([]);\n        });\n    }\n  } else {\n    setUserRoles([]);\n  }\n}, [isAuthenticated, user]);\n\n// Add hasRole function to context\nconst hasRole = useCallback((role: string) => {\n  return userRoles.includes(role);\n}, [userRoles]);\n\n// Add to context value\nconst contextValue: AuthContextProps = {\n  // Existing properties...\n  userRoles,\n  hasRole\n};\n```\n\n5. Create a role-based component for conditional rendering:\n```typescript\nimport React from 'react';\nimport { useAuth } from '../auth/AuthContext';\n\ninterface RoleBasedProps {\n  requiredRole: string;\n  children: React.ReactNode;\n  fallback?: React.ReactNode;\n}\n\nexport const RoleBased: React.FC<RoleBasedProps> = ({ \n  requiredRole, \n  children, \n  fallback = null \n}) => {\n  const { hasRole } = useAuth();\n  \n  return hasRole(requiredRole) ? <>{children}</> : <>{fallback}</>;\n};\n```\n\n6. Use the role-based component in the UI:\n```tsx\n<RoleBased requiredRole=\"Admin\">\n  <AdminPanel />\n</RoleBased>\n```",
      "testStrategy": "1. Test role extraction from Azure AD tokens\n2. Verify role-based authorization policies\n3. Test role-based UI rendering\n4. Verify role synchronization between Azure AD and the application\n5. Test access control for different user roles\n6. Verify role updates are reflected in the application",
      "priority": "medium",
      "dependencies": [
        5,
        11
      ],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "Configure Azure AD Roles",
          "description": "Set up and assign appropriate roles in Azure Active Directory using the Azure portal. This includes creating custom roles if needed, assigning roles to users, groups, or service principals, and ensuring the correct scope and permissions are applied.",
          "dependencies": [],
          "details": "Follow Azure portal steps to create and assign roles: navigate to Access control (IAM), select or create roles, assign them to users/groups/service principals, and document the assignments for reference.[1][2][5]",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Implement Backend Role Extraction",
          "description": "Develop backend logic to extract and process user roles from Azure AD tokens or claims after authentication. Ensure roles are correctly mapped and available for authorization checks.",
          "dependencies": [
            1
          ],
          "details": "Integrate with Azure AD authentication flow, parse tokens to extract assigned roles, and make roles accessible in backend user context for downstream authorization.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Update Authorization Policies in Backend",
          "description": "Update or create backend authorization policies to enforce access control based on extracted roles. Ensure that endpoints and resources are protected according to role requirements.",
          "dependencies": [
            2
          ],
          "details": "Define and implement policy logic (e.g., middleware, decorators, or attribute-based access control) that checks user roles before granting access to protected resources.",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Handle Roles in Frontend Authentication Flow",
          "description": "Update frontend authentication logic to retrieve and process user roles from authentication tokens or APIs. Ensure the frontend is aware of the user's roles for UI and routing decisions.",
          "dependencies": [
            2
          ],
          "details": "Parse roles from ID/access tokens or fetch from backend, store roles in frontend state management, and make them available for UI logic.",
          "status": "pending"
        },
        {
          "id": 5,
          "title": "Implement Role-Based UI Components",
          "description": "Develop UI components and logic that render or restrict features based on the user's roles. Ensure that only authorized users see or interact with role-protected UI elements.",
          "dependencies": [
            4
          ],
          "details": "Use role information in frontend to conditionally display menus, buttons, and pages. Implement guards or wrappers to enforce role-based visibility and actions.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 15,
      "title": "Implement Comprehensive Testing",
      "description": "Create and execute a comprehensive testing plan for the Azure AD authentication implementation.",
      "details": "1. Create unit tests for authentication components:\n```typescript\n// Example test for AuthContext\nimport { render, screen, waitFor } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport { AuthProvider, useAuth } from '../auth/AuthContext';\nimport { MsalProvider } from '@azure/msal-react';\n\n// Mock MSAL\njest.mock('@azure/msal-react', () => ({\n  MsalProvider: ({ children }) => <div>{children}</div>,\n  useMsal: () => ({\n    instance: {\n      loginPopup: jest.fn().mockResolvedValue({}),\n      logoutPopup: jest.fn().mockResolvedValue({}),\n      acquireTokenSilent: jest.fn().mockResolvedValue({ accessToken: 'mock-token' })\n    },\n    accounts: [{ username: 'test@example.com', name: 'Test User' }],\n    inProgress: 'none'\n  }),\n  useAccount: () => ({\n    username: 'test@example.com',\n    name: 'Test User',\n    idTokenClaims: { roles: ['User'] }\n  })\n}));\n\n// Test component that uses auth context\nconst TestComponent = () => {\n  const { isAuthenticated, login, logout } = useAuth();\n  return (\n    <div>\n      <div data-testid=\"auth-status\">{isAuthenticated ? 'Authenticated' : 'Not authenticated'}</div>\n      <button onClick={login} data-testid=\"login-button\">Login</button>\n      <button onClick={logout} data-testid=\"logout-button\">Logout</button>\n    </div>\n  );\n};\n\ndescribe('AuthContext', () => {\n  test('provides authentication state', async () => {\n    render(\n      <AuthProvider>\n        <TestComponent />\n      </AuthProvider>\n    );\n    \n    // Should be authenticated due to mock account\n    await waitFor(() => {\n      expect(screen.getByTestId('auth-status')).toHaveTextContent('Authenticated');\n    });\n  });\n  \n  test('handles login', async () => {\n    render(\n      <AuthProvider>\n        <TestComponent />\n      </AuthProvider>\n    );\n    \n    const loginButton = screen.getByTestId('login-button');\n    userEvent.click(loginButton);\n    \n    // Verify login was called\n    await waitFor(() => {\n      expect(screen.getByTestId('auth-status')).toHaveTextContent('Authenticated');\n    });\n  });\n});\n```\n\n2. Create integration tests for API authentication:\n```csharp\n[Fact]\npublic async Task Authenticated_Request_Should_Access_Protected_Endpoint()\n{\n    // Arrange\n    var client = _factory.CreateClient();\n    var token = GenerateTestToken(\"test-user\", new[] { \"User\" });\n    client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue(\"Bearer\", token);\n    \n    // Act\n    var response = await client.GetAsync(\"/api/projects\");\n    \n    // Assert\n    response.EnsureSuccessStatusCode();\n    var content = await response.Content.ReadAsStringAsync();\n    Assert.Contains(\"projects\", content.ToLower());\n}\n\n[Fact]\npublic async Task Unauthenticated_Request_Should_Be_Rejected()\n{\n    // Arrange\n    var client = _factory.CreateClient();\n    \n    // Act\n    var response = await client.GetAsync(\"/api/projects\");\n    \n    // Assert\n    Assert.Equal(HttpStatusCode.Unauthorized, response.StatusCode);\n}\n\n[Fact]\npublic async Task Admin_Role_Should_Access_Admin_Endpoint()\n{\n    // Arrange\n    var client = _factory.CreateClient();\n    var token = GenerateTestToken(\"admin-user\", new[] { \"Admin\" });\n    client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue(\"Bearer\", token);\n    \n    // Act\n    var response = await client.GetAsync(\"/api/admin/users\");\n    \n    // Assert\n    response.EnsureSuccessStatusCode();\n}\n\n[Fact]\npublic async Task User_Role_Should_Not_Access_Admin_Endpoint()\n{\n    // Arrange\n    var client = _factory.CreateClient();\n    var token = GenerateTestToken(\"regular-user\", new[] { \"User\" });\n    client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue(\"Bearer\", token);\n    \n    // Act\n    var response = await client.GetAsync(\"/api/admin/users\");\n    \n    // Assert\n    Assert.Equal(HttpStatusCode.Forbidden, response.StatusCode);\n}\n\nprivate string GenerateTestToken(string username, string[] roles)\n{\n    // Create test JWT token for testing\n    // This is a simplified version - in a real test you would use a library\n    // to generate a properly signed token\n    var tokenHandler = new JwtSecurityTokenHandler();\n    var key = Encoding.ASCII.GetBytes(\"test-signing-key-for-testing-only\");\n    var tokenDescriptor = new SecurityTokenDescriptor\n    {\n        Subject = new ClaimsIdentity(new Claim[] \n        {\n            new Claim(JwtRegisteredClaimNames.Sub, username),\n            new Claim(JwtRegisteredClaimNames.Email, $\"{username}@example.com\"),\n            new Claim(\"http://schemas.microsoft.com/identity/claims/objectidentifier\", Guid.NewGuid().ToString())\n        }.Concat(roles.Select(role => new Claim(ClaimTypes.Role, role))).ToArray()),\n        Expires = DateTime.UtcNow.AddHours(1),\n        SigningCredentials = new SigningCredentials(new SymmetricSecurityKey(key), SecurityAlgorithms.HmacSha256Signature),\n        Issuer = \"https://login.microsoftonline.com/test-tenant-id/\",\n        Audience = \"test-client-id\"\n    };\n    var token = tokenHandler.CreateToken(tokenDescriptor);\n    return tokenHandler.WriteToken(token);\n}\n```\n\n3. Create end-to-end tests for authentication flows:\n```typescript\n// Using Cypress for E2E testing\ndescribe('Authentication Flow', () => {\n  beforeEach(() => {\n    // Mock MSAL for testing\n    cy.intercept('POST', 'https://login.microsoftonline.com/*/oauth2/v2.0/token', {\n      statusCode: 200,\n      body: {\n        access_token: 'mock-access-token',\n        id_token: 'mock-id-token',\n        expires_in: 3600\n      }\n    }).as('getToken');\n    \n    // Mock user API\n    cy.intercept('GET', '/api/user/me', {\n      statusCode: 200,\n      body: {\n        id: 1,\n        email: 'test@example.com',\n        displayName: 'Test User',\n        roles: ['User']\n      }\n    }).as('getUser');\n  });\n  \n  it('should redirect unauthenticated users to login', () => {\n    cy.visit('/dashboard');\n    cy.url().should('include', '/login');\n  });\n  \n  it('should allow login and access to protected routes', () => {\n    // Visit login page\n    cy.visit('/login');\n    \n    // Click login button (this will trigger the mocked MSAL flow)\n    cy.get('[data-testid=login-button]').click();\n    \n    // Wait for token request to complete\n    cy.wait('@getToken');\n    \n    // Should redirect to dashboard\n    cy.url().should('include', '/dashboard');\n    \n    // User info should be displayed\n    cy.get('[data-testid=user-profile]').should('contain', 'Test User');\n  });\n  \n  it('should maintain session on page refresh', () => {\n    // Set up session storage to simulate authenticated state\n    cy.window().then(window => {\n      // Mock MSAL cache in session storage\n      const mockCache = {\n        accounts: [{\n          homeAccountId: 'test-account-id',\n          environment: 'login.microsoftonline.com',\n          tenantId: 'test-tenant-id',\n          username: 'test@example.com',\n          name: 'Test User'\n        }],\n        accessTokens: {\n          'test-token-key': {\n            homeAccountId: 'test-account-id',\n            credentialType: 'AccessToken',\n            secret: 'mock-access-token',\n            cachedAt: Date.now(),\n            expiresOn: Date.now() + 3600000\n          }\n        }\n      };\n      \n      window.sessionStorage.setItem(\n        `msal.${msalConfig.auth.clientId}.cache`, \n        JSON.stringify(mockCache)\n      );\n    });\n    \n    // Visit protected route\n    cy.visit('/dashboard');\n    \n    // Should not redirect to login\n    cy.url().should('include', '/dashboard');\n    \n    // User info should be displayed\n    cy.get('[data-testid=user-profile]').should('contain', 'Test User');\n  });\n  \n  it('should log out successfully', () => {\n    // Set up authenticated session\n    cy.window().then(window => {\n      // Mock MSAL cache in session storage as above\n    });\n    \n    // Visit dashboard\n    cy.visit('/dashboard');\n    \n    // Click logout button\n    cy.get('[data-testid=logout-button]').click();\n    \n    // Should redirect to login page\n    cy.url().should('include', '/login');\n    \n    // Session storage should be cleared\n    cy.window().then(window => {\n      expect(window.sessionStorage.getItem(`msal.${msalConfig.auth.clientId}.cache`)).to.be.null;\n    });\n  });\n});\n```\n\n4. Create performance tests for token validation:\n```csharp\n[Benchmark]\npublic async Task TokenValidation_Performance()\n{\n    // Arrange\n    var tokenHandler = new JwtSecurityTokenHandler();\n    var validationParameters = new TokenValidationParameters\n    {\n        ValidateIssuer = true,\n        ValidIssuer = \"https://login.microsoftonline.com/test-tenant-id/\",\n        ValidateAudience = true,\n        ValidAudience = \"test-client-id\",\n        ValidateLifetime = true,\n        IssuerSigningKey = new SymmetricSecurityKey(Encoding.ASCII.GetBytes(\"test-signing-key\"))\n    };\n    var token = GenerateTestToken(\"test-user\", new[] { \"User\" });\n    \n    // Act\n    for (int i = 0; i < 1000; i++)\n    {\n        var principal = tokenHandler.ValidateToken(\n            token, \n            validationParameters, \n            out var validatedToken);\n    }\n}\n```\n\n5. Create a test plan document covering all authentication scenarios:\n   - Login flows (success and failure cases)\n   - Logout flows\n   - Token refresh scenarios\n   - Session persistence\n   - Role-based access control\n   - Error handling\n   - Performance testing\n   - Security testing (including CORS, token storage, etc.)",
      "testStrategy": "1. Execute unit tests for all authentication components\n2. Run integration tests for API authentication\n3. Perform end-to-end tests for authentication flows\n4. Conduct performance tests for token validation\n5. Verify security aspects (token storage, CORS, etc.)\n6. Test on all required browsers and devices\n7. Validate all user stories and acceptance criteria\n8. Perform load testing with multiple simultaneous users\n9. Document test results and any issues found",
      "priority": "high",
      "dependencies": [
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14
      ],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "Develop Unit Testing Strategy",
          "description": "Create comprehensive unit tests for all authentication components",
          "dependencies": [],
          "details": "Implement unit tests for individual authentication functions, password hashing, token generation, and validation logic. Mock external dependencies and create test fixtures for different authentication scenarios. Aim for at least 80% code coverage.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Implement Integration Testing",
          "description": "Develop tests to verify interactions between authentication components",
          "dependencies": [
            1
          ],
          "details": "Create integration tests that verify the authentication flow across multiple components. Test database interactions, API endpoints, and service communications. Include positive and negative test cases for login flows, registration, password reset, and session management.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Set Up End-to-End Testing",
          "description": "Create automated E2E tests simulating real user authentication flows",
          "dependencies": [
            2
          ],
          "details": "Implement end-to-end tests using tools like Cypress or Selenium that simulate complete user journeys through the authentication system. Test login, logout, registration, account recovery, and SSO authentication flows across different browsers and devices.",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Conduct Security Testing",
          "description": "Perform security-specific testing of the authentication system",
          "dependencies": [
            2
          ],
          "details": "Implement penetration testing following OWASP methodologies to identify vulnerabilities. Test for credential transport encryption, brute force protection, session management, and other security concerns. Include vulnerability scanning and risk assessment in the security testing process.",
          "status": "pending"
        },
        {
          "id": 5,
          "title": "Execute Performance Testing",
          "description": "Test authentication system performance under various load conditions",
          "dependencies": [
            3
          ],
          "details": "Create performance tests to measure authentication response times, system throughput, and resource utilization under normal and peak loads. Test concurrent authentication requests, session creation rates, and token validation performance. Identify bottlenecks and optimization opportunities.",
          "status": "pending"
        },
        {
          "id": 6,
          "title": "Create Test Documentation",
          "description": "Document all testing strategies, procedures, and results",
          "dependencies": [
            1,
            2,
            3,
            4,
            5
          ],
          "details": "Develop comprehensive test documentation including test plans, test cases, testing procedures, and test results for all testing types. Create a test coverage report and document any identified issues with severity ratings and remediation recommendations.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 16,
      "title": "Implement Role Management UI",
      "description": "Create a comprehensive role and permission management interface that integrates with the new RolesController backend.",
      "details": "Create a Role Management UI following the established FourSPM patterns:\n\n1. **Component Structure**:\n   - Follow the two-layer component pattern with a provider wrapper and content component\n   - Implement proper context separation for data vs. UI state\n   - Use DevExtreme ODataGrid for the roles list\n\n2. **State Management**:\n   - Use React Query for data fetching with the new role endpoints\n   - Implement proper loading states and error handling\n   - Use context for local UI state management\n\n3. **UI Components**:\n   - Create a roles grid showing role name, description, and system role status\n   - Implement a role editor form for adding/editing roles\n   - Create a permission assignment interface with grouped checkboxes\n   - Support mobile and desktop layouts with responsive design\n\n4. **Features**:\n   - CRUD operations for roles\n   - Permission assignment and removal\n   - System role protection (prevent editing/deleting system roles)\n   - Search/filter functionality\n   - Clear error messaging\n\n5. **Integration**:\n   - Add to the Administration section of the navigation\n   - Ensure proper permission checks for accessing the UI\n   - Handle token refresh scenarios",
      "testStrategy": "1. Verify the Role Management UI follows the Collection View Doctrine\n2. Test CRUD operations against the backend\n3. Verify permissions can be assigned and removed\n4. Test responsive design on different viewport sizes\n5. Verify system roles are properly protected\n6. Test error scenarios (network errors, validation errors)\n7. Verify proper loading states are shown\n8. Test search and filter functionality\n9. Verify the UI correctly reflects permission changes",
      "status": "pending",
      "dependencies": [
        5
      ],
      "priority": "medium",
      "subtasks": [
        {
          "id": 1,
          "title": "Design Role Management Component Structure",
          "description": "Create the component hierarchy and architecture for the role management UI",
          "dependencies": [],
          "details": "Define the component structure including parent-child relationships, reusable components, and the overall architecture. Create wireframes for role listing, role details, permission assignment, and user-role association views. Consider responsive design requirements for different screen sizes.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Implement State Management for Roles",
          "description": "Develop state management solution for handling role data and operations",
          "dependencies": [
            1
          ],
          "details": "Create state management for role CRUD operations, permission assignments, and user-role associations. Implement data fetching, caching strategies, and optimistic updates. Design state structure to efficiently handle role hierarchies and permission inheritance as described in role management systems.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Build Core UI Components",
          "description": "Develop the essential UI components needed for role management",
          "dependencies": [
            1
          ],
          "details": "Create reusable UI components including role cards, permission checkboxes, role assignment dropdowns, search/filter functionality, and confirmation dialogs. Ensure components follow design system guidelines and include proper accessibility features.",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Implement Role CRUD Operations",
          "description": "Develop interfaces for creating, reading, updating, and deleting roles",
          "dependencies": [
            2,
            3
          ],
          "details": "Build UI screens and logic for role creation, viewing role details, editing roles, and role deletion with appropriate confirmation flows. Include validation for role names, descriptions, and permission assignments. Implement error handling and success notifications.",
          "status": "pending"
        },
        {
          "id": 5,
          "title": "Develop Permission Assignment Features",
          "description": "Create interfaces for assigning and managing permissions within roles",
          "dependencies": [
            4
          ],
          "details": "Implement UI for assigning permissions to roles, including hierarchical permission structures, bulk permission operations, and permission inheritance visualization. Create interfaces for testing role configurations before deployment as recommended in role management best practices.",
          "status": "pending"
        },
        {
          "id": 6,
          "title": "Integrate with Navigation and User Systems",
          "description": "Connect role management UI with navigation and user management systems",
          "dependencies": [
            4,
            5
          ],
          "details": "Integrate role management with the application navigation system, implementing role-based UI adaptation. Connect with user management to enable assigning users to roles and displaying role-specific interfaces. Implement automated role assignment workflows and ensure proper authorization checks throughout the application.",
          "status": "pending"
        }
      ]
    }
  ]
}